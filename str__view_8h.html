<!DOCTYPE html PUBLIC "-//W3C//DTD XHTML 1.0 Transitional//EN" "https://www.w3.org/TR/xhtml1/DTD/xhtml1-transitional.dtd">
<html xmlns="http://www.w3.org/1999/xhtml" lang="en-US">
<head>
<meta http-equiv="Content-Type" content="text/xhtml;charset=UTF-8"/>
<meta http-equiv="X-UA-Compatible" content="IE=11"/>
<meta name="generator" content="Doxygen 1.9.6"/>
<meta name="viewport" content="width=device-width, initial-scale=1"/>
<title>Str View: str_view/str_view.h File Reference</title>
<link href="tabs.css" rel="stylesheet" type="text/css"/>
<script type="text/javascript" src="jquery.js"></script>
<script type="text/javascript" src="dynsections.js"></script>
<link href="navtree.css" rel="stylesheet" type="text/css"/>
<script type="text/javascript" src="resize.js"></script>
<script type="text/javascript" src="navtreedata.js"></script>
<script type="text/javascript" src="navtree.js"></script>
<link href="search/search.css" rel="stylesheet" type="text/css"/>
<script type="text/javascript" src="search/searchdata.js"></script>
<script type="text/javascript" src="search/search.js"></script>
<link href="doxygen.css" rel="stylesheet" type="text/css" />
<link href="doxygen-awesome.css" rel="stylesheet" type="text/css"/>
</head>
<body>
<div id="top"><!-- do not remove this div, it is closed by doxygen! -->
<div id="titlearea">
<table cellspacing="0" cellpadding="0">
 <tbody>
 <tr id="projectrow">
  <td id="projectalign">
   <div id="projectname">Str View
   </div>
  </td>
 </tr>
 </tbody>
</table>
</div>
<!-- end header part -->
<!-- Generated by Doxygen 1.9.6 -->
<script type="text/javascript">
/* @license magnet:?xt=urn:btih:d3d9a9a6595521f9666a5e94cc830dab83b65699&amp;dn=expat.txt MIT */
var searchBox = new SearchBox("searchBox", "search/",'.html');
/* @license-end */
</script>
<script type="text/javascript" src="menudata.js"></script>
<script type="text/javascript" src="menu.js"></script>
<script type="text/javascript">
/* @license magnet:?xt=urn:btih:d3d9a9a6595521f9666a5e94cc830dab83b65699&amp;dn=expat.txt MIT */
$(function() {
  initMenu('',true,false,'search.php','Search');
  $(document).ready(function() { init_search(); });
});
/* @license-end */
</script>
<div id="main-nav"></div>
</div><!-- top -->
<div id="side-nav" class="ui-resizable side-nav-resizable">
  <div id="nav-tree">
    <div id="nav-tree-contents">
      <div id="nav-sync" class="sync"></div>
    </div>
  </div>
  <div id="splitbar" style="-moz-user-select:none;" 
       class="ui-resizable-handle">
  </div>
</div>
<script type="text/javascript">
/* @license magnet:?xt=urn:btih:d3d9a9a6595521f9666a5e94cc830dab83b65699&amp;dn=expat.txt MIT */
$(document).ready(function(){initNavTree('str__view_8h.html',''); initResizable(); });
/* @license-end */
</script>
<div id="doc-content">
<!-- window showing the filter options -->
<div id="MSearchSelectWindow"
     onmouseover="return searchBox.OnSearchSelectShow()"
     onmouseout="return searchBox.OnSearchSelectHide()"
     onkeydown="return searchBox.OnSearchSelectKey(event)">
</div>

<!-- iframe showing the search results (closed by default) -->
<div id="MSearchResultsWindow">
<div id="MSearchResults">
<div class="SRPage">
<div id="SRIndex">
<div id="SRResults"></div>
<div class="SRStatus" id="Loading">Loading...</div>
<div class="SRStatus" id="Searching">Searching...</div>
<div class="SRStatus" id="NoMatches">No Matches</div>
</div>
</div>
</div>
</div>

<div class="header">
  <div class="summary">
<a href="#nested-classes">Data Structures</a> &#124;
<a href="#define-members">Macros</a>  </div>
  <div class="headertitle"><div class="title">str_view.h File Reference</div></div>
</div><!--header-->
<div class="contents">

<p>The <code><a class="el" href="structSV__Str__view.html" title="A read-only view of string data in C.">SV_Str_view</a></code> Interface.  
<a href="#details">More...</a></p>
<div class="textblock"><code>#include &lt;stdbool.h&gt;</code><br />
<code>#include &lt;stddef.h&gt;</code><br />
</div><div class="textblock"><div class="dynheader">
Include dependency graph for str_view.h:</div>
<div class="dyncontent">
<div class="center"><img src="str__view_8h__incl.png" border="0" usemap="#astr__view_2str__view_8h" alt=""/></div>
<map name="astr__view_2str__view_8h" id="astr__view_2str__view_8h">
<area shape="rect" title="The SV_Str_view Interface." alt="" coords="24,5,171,31"/>
<area shape="rect" title=" " alt="" coords="5,79,88,104"/>
<area shape="rect" title=" " alt="" coords="112,79,187,104"/>
</map>
</div>
</div>
<p><a href="str__view_8h_source.html">Go to the source code of this file.</a></p>
<a name="details" id="details"></a><h2 class="groupheader">Detailed Description</h2>
<div class="textblock"><p>The <code><a class="el" href="structSV__Str__view.html" title="A read-only view of string data in C.">SV_Str_view</a></code> Interface. </p>
<p>A <code><a class="el" href="structSV__Str__view.html" title="A read-only view of string data in C.">SV_Str_view</a></code> is a read only view of null terminated C strings. It's purpose is to provide robust read only string construction, tokenizing, and matching. This introduces tremendous flexibility to string handling in C programming from low-level kernel code to application layer programming.</p>
<p>Read only string handling offers many safety benefits as well. All functions in the interface are either constant or pure functions. This means that given the same inputs, they will provide the same outputs. And because no functions can modify the underlying string, compilers can often help use these guarantees to produce faster code. This also means that all string view functions are inherently safe to be used from multiple threads over the same string data.</p>
<p>This interface also aims to provide robust read only tokenization without any of the concerns that come with functions like <code>strtok</code> versus <code>strtok_r</code>. Tokenization can occur simultaneously from multiple threads and a natural iteration abstraction is provided.</p>
<p>Finally, all major string matching functions are provided and run in linear time, using constant space. There are also variants of the substring matching algorithms that run in reverse providing the optimal time complexity for reverse string matching. Constant space complexity is an important component of maintaining the pure attributes of the searching function. Regardless of the underlying string matching algorithm, no side effects occur and no auxiliary global or static global storage is needed. </p>
</div><table class="memberdecls">
<tr class="heading"><td colspan="2"><h2 class="groupheader"><a id="nested-classes" name="nested-classes"></a>
Data Structures</h2></td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">struct &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="structSV__Str__view.html">SV_Str_view</a></td></tr>
<tr class="memdesc:"><td class="mdescLeft">&#160;</td><td class="mdescRight">A read-only view of string data in C.  <a href="structSV__Str__view.html#details">More...</a><br /></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
</table><table class="memberdecls">
<tr class="heading"><td colspan="2"><h2 class="groupheader"><a id="define-members" name="define-members"></a>
Macros</h2></td></tr>
<tr class="memitem:a8bc45837a6af4c6f8a18d674626bbe34"><td class="memItemLeft" align="right" valign="top"><a id="a8bc45837a6af4c6f8a18d674626bbe34" name="a8bc45837a6af4c6f8a18d674626bbe34"></a>
#define&#160;</td><td class="memItemRight" valign="bottom"><b>SV_ATTRIB_PURE</b></td></tr>
<tr class="memdesc:a8bc45837a6af4c6f8a18d674626bbe34"><td class="mdescLeft">&#160;</td><td class="mdescRight">Describes a function as having no side effects when given the same arguments with same underlying data. Can be used when pointers are provided. <br /></td></tr>
<tr class="separator:a8bc45837a6af4c6f8a18d674626bbe34"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:aa8df9c93f659cdd2543c3c1f11236bb4"><td class="memItemLeft" align="right" valign="top"><a id="aa8df9c93f659cdd2543c3c1f11236bb4" name="aa8df9c93f659cdd2543c3c1f11236bb4"></a>
#define&#160;</td><td class="memItemRight" valign="bottom"><b>SV_ATTRIB_CONST</b></td></tr>
<tr class="memdesc:aa8df9c93f659cdd2543c3c1f11236bb4"><td class="mdescLeft">&#160;</td><td class="mdescRight">Describes a function as having no side effects and not depending on any pointer input that could change between calls. <br /></td></tr>
<tr class="separator:aa8df9c93f659cdd2543c3c1f11236bb4"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a15ca829e06962ad8c8c690db021ba2ef"><td class="memItemLeft" align="right" valign="top"><a id="a15ca829e06962ad8c8c690db021ba2ef" name="a15ca829e06962ad8c8c690db021ba2ef"></a>
#define&#160;</td><td class="memItemRight" valign="bottom"><b>SV_ATTRIB_NULLTERM</b>(...)</td></tr>
<tr class="memdesc:a15ca829e06962ad8c8c690db021ba2ef"><td class="mdescLeft">&#160;</td><td class="mdescRight">Describes a parameter as null terminated. <br /></td></tr>
<tr class="separator:a15ca829e06962ad8c8c690db021ba2ef"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a6efdaade95a9e224ba814c928204e4dc"><td class="memItemLeft" align="right" valign="top"><a id="a6efdaade95a9e224ba814c928204e4dc" name="a6efdaade95a9e224ba814c928204e4dc"></a>
#define&#160;</td><td class="memItemRight" valign="bottom"><b>SV_STR_LITERAL</b>(str_literal)&#160;&#160;&#160;str_literal</td></tr>
<tr class="memdesc:a6efdaade95a9e224ba814c928204e4dc"><td class="mdescLeft">&#160;</td><td class="mdescRight">MSVC does not allow strong enforcement of string literals to the SV_from constructor. This is a dummy wrapper for compatibility. <br /></td></tr>
<tr class="separator:a6efdaade95a9e224ba814c928204e4dc"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ab632a39b679bbed9a2f8a8cbb6c04807"><td class="memItemLeft" align="right" valign="top"><a id="ab632a39b679bbed9a2f8a8cbb6c04807" name="ab632a39b679bbed9a2f8a8cbb6c04807"></a>
#define&#160;</td><td class="memItemRight" valign="bottom"><b>SV_API</b></td></tr>
<tr class="memdesc:ab632a39b679bbed9a2f8a8cbb6c04807"><td class="mdescLeft">&#160;</td><td class="mdescRight">A macro to help with library linking on windows. <br /></td></tr>
<tr class="separator:ab632a39b679bbed9a2f8a8cbb6c04807"><td class="memSeparator" colspan="2">&#160;</td></tr>
</table><table class="memberdecls">
<tr class="heading"><td colspan="2"><h2 class="groupheader">Construction</h2></td></tr>
<tr><td class="ititle" colspan="2"><p>A macro and functions for constructing a <code><a class="el" href="structSV__Str__view.html" title="A read-only view of string data in C.">SV_Str_view</a></code>. </p>
</td></tr>
<tr class="memitem:ab735680cc4059381ce2cad6c8fc690d3"><td class="memItemLeft" align="right" valign="top">#define&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="str__view_8h.html#ab735680cc4059381ce2cad6c8fc690d3">SV_from</a>(str_literal)&#160;&#160;&#160;    ((<a class="el" href="structSV__Str__view.html">SV_Str_view</a>){<a class="el" href="str__view_8h.html#a6efdaade95a9e224ba814c928204e4dc">SV_STR_LITERAL</a>(str_literal), sizeof(str_literal) - 1})</td></tr>
<tr class="memdesc:ab735680cc4059381ce2cad6c8fc690d3"><td class="mdescLeft">&#160;</td><td class="mdescRight">A macro to reduce the chance for errors in repeating oneself when constructing an inline or const <a class="el" href="structSV__Str__view.html" title="A read-only view of string data in C.">SV_Str_view</a>. The input must be a string literal.  <br /></td></tr>
<tr class="separator:ab735680cc4059381ce2cad6c8fc690d3"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:acfe5d77c0a37dfeafc737e62abd8aa19"><td class="memItemLeft" align="right" valign="top"><a class="el" href="str__view_8h.html#ab632a39b679bbed9a2f8a8cbb6c04807">SV_API</a> <a class="el" href="structSV__Str__view.html">SV_Str_view</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="str__view_8h.html#acfe5d77c0a37dfeafc737e62abd8aa19">SV_from_terminated</a> (char const *str) <a class="el" href="str__view_8h.html#a15ca829e06962ad8c8c690db021ba2ef">SV_ATTRIB_NULLTERM</a>(1) <a class="el" href="str__view_8h.html#a8bc45837a6af4c6f8a18d674626bbe34">SV_ATTRIB_PURE</a></td></tr>
<tr class="memdesc:acfe5d77c0a37dfeafc737e62abd8aa19"><td class="mdescLeft">&#160;</td><td class="mdescRight">Constructs and returns a string view from a null terminated string.  <br /></td></tr>
<tr class="separator:acfe5d77c0a37dfeafc737e62abd8aa19"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a2923ce2c520b5963cd37250b66e9d196"><td class="memItemLeft" align="right" valign="top"><a class="el" href="str__view_8h.html#ab632a39b679bbed9a2f8a8cbb6c04807">SV_API</a> <a class="el" href="structSV__Str__view.html">SV_Str_view</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="str__view_8h.html#a2923ce2c520b5963cd37250b66e9d196">SV_from_view</a> (size_t n, char const *str) <a class="el" href="str__view_8h.html#a15ca829e06962ad8c8c690db021ba2ef">SV_ATTRIB_NULLTERM</a>(2) <a class="el" href="str__view_8h.html#a8bc45837a6af4c6f8a18d674626bbe34">SV_ATTRIB_PURE</a></td></tr>
<tr class="memdesc:a2923ce2c520b5963cd37250b66e9d196"><td class="mdescLeft">&#160;</td><td class="mdescRight">Constructs and returns a string view from a sequence of valid n bytes or string length, whichever comes first.  <br /></td></tr>
<tr class="separator:a2923ce2c520b5963cd37250b66e9d196"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a146a05bec7fd24999d74a2fa46223b9a"><td class="memItemLeft" align="right" valign="top"><a class="el" href="str__view_8h.html#ab632a39b679bbed9a2f8a8cbb6c04807">SV_API</a> <a class="el" href="structSV__Str__view.html">SV_Str_view</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="str__view_8h.html#a146a05bec7fd24999d74a2fa46223b9a">SV_from_delimiter</a> (char const *str, char const *delim) <a class="el" href="str__view_8h.html#a15ca829e06962ad8c8c690db021ba2ef">SV_ATTRIB_NULLTERM</a>(1) <a class="el" href="str__view_8h.html#a15ca829e06962ad8c8c690db021ba2ef">SV_ATTRIB_NULLTERM</a>(2) <a class="el" href="str__view_8h.html#a8bc45837a6af4c6f8a18d674626bbe34">SV_ATTRIB_PURE</a></td></tr>
<tr class="memdesc:a146a05bec7fd24999d74a2fa46223b9a"><td class="mdescLeft">&#160;</td><td class="mdescRight">Constructs and returns a string view from a null terminated string broken on the first occurrence of delimiter if found or null terminator if delim cannot be found.  <br /></td></tr>
<tr class="separator:a146a05bec7fd24999d74a2fa46223b9a"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a6ffc135012b68a396f786638f5ac6278"><td class="memItemLeft" align="right" valign="top"><a class="el" href="str__view_8h.html#ab632a39b679bbed9a2f8a8cbb6c04807">SV_API</a> <a class="el" href="structSV__Str__view.html">SV_Str_view</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="str__view_8h.html#a6ffc135012b68a396f786638f5ac6278">SV_substr</a> (<a class="el" href="structSV__Str__view.html">SV_Str_view</a> sv, size_t pos, size_t count) <a class="el" href="str__view_8h.html#a8bc45837a6af4c6f8a18d674626bbe34">SV_ATTRIB_PURE</a></td></tr>
<tr class="memdesc:a6ffc135012b68a396f786638f5ac6278"><td class="mdescLeft">&#160;</td><td class="mdescRight">Creates the substring from position pos for count length. The count is the minimum value between count and <code>(length - pos)</code>.  <br /></td></tr>
<tr class="separator:a6ffc135012b68a396f786638f5ac6278"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a62b1315242b9acfbfdd38dcbefe0e7f3"><td class="memItemLeft" align="right" valign="top"><a class="el" href="str__view_8h.html#ab632a39b679bbed9a2f8a8cbb6c04807">SV_API</a> size_t&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="str__view_8h.html#a62b1315242b9acfbfdd38dcbefe0e7f3">SV_str_bytes</a> (char const *str) <a class="el" href="str__view_8h.html#a15ca829e06962ad8c8c690db021ba2ef">SV_ATTRIB_NULLTERM</a>(1) <a class="el" href="str__view_8h.html#a8bc45837a6af4c6f8a18d674626bbe34">SV_ATTRIB_PURE</a></td></tr>
<tr class="memdesc:a62b1315242b9acfbfdd38dcbefe0e7f3"><td class="mdescLeft">&#160;</td><td class="mdescRight">Returns the bytes of the string pointer to, null terminator included.  <br /></td></tr>
<tr class="separator:a62b1315242b9acfbfdd38dcbefe0e7f3"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ac18f3e34b3533cb52347d9b18c05fb56"><td class="memItemLeft" align="right" valign="top"><a class="el" href="str__view_8h.html#ab632a39b679bbed9a2f8a8cbb6c04807">SV_API</a> <a class="el" href="structSV__Str__view.html">SV_Str_view</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="str__view_8h.html#ac18f3e34b3533cb52347d9b18c05fb56">SV_copy</a> (size_t str_bytes, char const *src_str) <a class="el" href="str__view_8h.html#a15ca829e06962ad8c8c690db021ba2ef">SV_ATTRIB_NULLTERM</a>(2) <a class="el" href="str__view_8h.html#a8bc45837a6af4c6f8a18d674626bbe34">SV_ATTRIB_PURE</a></td></tr>
<tr class="memdesc:ac18f3e34b3533cb52347d9b18c05fb56"><td class="mdescLeft">&#160;</td><td class="mdescRight">Copies the max of string bytes or input string length into a view, whichever ends first.  <br /></td></tr>
<tr class="separator:ac18f3e34b3533cb52347d9b18c05fb56"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a73ef3f2b4b5fb182d447544677c7282c"><td class="memItemLeft" align="right" valign="top"><a class="el" href="str__view_8h.html#ab632a39b679bbed9a2f8a8cbb6c04807">SV_API</a> size_t&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="str__view_8h.html#a73ef3f2b4b5fb182d447544677c7282c">SV_fill</a> (size_t dest_bytes, char *dest_buf, <a class="el" href="structSV__Str__view.html">SV_Str_view</a> src)</td></tr>
<tr class="memdesc:a73ef3f2b4b5fb182d447544677c7282c"><td class="mdescLeft">&#160;</td><td class="mdescRight">Fills the destination buffer with the minimum between destination size and source view size, null terminating the string.  <br /></td></tr>
<tr class="separator:a73ef3f2b4b5fb182d447544677c7282c"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:adf51d3f645a2f24fa6f6a2fbece51cdc"><td class="memItemLeft" align="right" valign="top"><a class="el" href="str__view_8h.html#ab632a39b679bbed9a2f8a8cbb6c04807">SV_API</a> <a class="el" href="structSV__Str__view.html">SV_Str_view</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="str__view_8h.html#adf51d3f645a2f24fa6f6a2fbece51cdc">SV_extend</a> (<a class="el" href="structSV__Str__view.html">SV_Str_view</a> sv) <a class="el" href="str__view_8h.html#a8bc45837a6af4c6f8a18d674626bbe34">SV_ATTRIB_PURE</a></td></tr>
<tr class="memdesc:adf51d3f645a2f24fa6f6a2fbece51cdc"><td class="mdescLeft">&#160;</td><td class="mdescRight">Returns a <a class="el" href="structSV__Str__view.html" title="A read-only view of string data in C.">SV_Str_view</a> of the entirety of the underlying string, starting at the current view pointer position.  <br /></td></tr>
<tr class="separator:adf51d3f645a2f24fa6f6a2fbece51cdc"><td class="memSeparator" colspan="2">&#160;</td></tr>
</table><table class="memberdecls">
<tr class="heading"><td colspan="2"><h2 class="groupheader">Types</h2></td></tr>
<tr><td class="ititle" colspan="2"><p>The types of the <code><a class="el" href="structSV__Str__view.html" title="A read-only view of string data in C.">SV_Str_view</a></code> interface. </p>
</td></tr>
<tr class="memitem:a648d7dfc8555055b2e5b742d0aa6fdf7"><td class="memItemLeft" align="right" valign="top">enum &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="str__view_8h.html#a648d7dfc8555055b2e5b742d0aa6fdf7">SV_Order</a> { <b>SV_ORDER_LESSER</b> = -1
, <b>SV_ORDER_EQUAL</b>
, <b>SV_ORDER_GREATER</b>
, <b>SV_ORDER_ERROR</b>
 }</td></tr>
<tr class="memdesc:a648d7dfc8555055b2e5b742d0aa6fdf7"><td class="mdescLeft">&#160;</td><td class="mdescRight">Standard three way comparison type in C.  <a href="str__view_8h.html#a648d7dfc8555055b2e5b742d0aa6fdf7">More...</a><br /></td></tr>
<tr class="separator:a648d7dfc8555055b2e5b742d0aa6fdf7"><td class="memSeparator" colspan="2">&#160;</td></tr>
</table><table class="memberdecls">
<tr class="heading"><td colspan="2"><h2 class="groupheader">Comparison</h2></td></tr>
<tr><td class="ititle" colspan="2"><p>Comparing a <code><a class="el" href="structSV__Str__view.html" title="A read-only view of string data in C.">SV_Str_view</a></code> with another instance or a C string. </p>
</td></tr>
<tr class="memitem:a688dcdc0c6fe3901d71d114ad699c765"><td class="memItemLeft" align="right" valign="top"><a class="el" href="str__view_8h.html#ab632a39b679bbed9a2f8a8cbb6c04807">SV_API</a> <a class="el" href="str__view_8h.html#a648d7dfc8555055b2e5b742d0aa6fdf7">SV_Order</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="str__view_8h.html#a688dcdc0c6fe3901d71d114ad699c765">SV_compare</a> (<a class="el" href="structSV__Str__view.html">SV_Str_view</a> lhs, <a class="el" href="structSV__Str__view.html">SV_Str_view</a> rhs) <a class="el" href="str__view_8h.html#a8bc45837a6af4c6f8a18d674626bbe34">SV_ATTRIB_PURE</a></td></tr>
<tr class="memdesc:a688dcdc0c6fe3901d71d114ad699c765"><td class="mdescLeft">&#160;</td><td class="mdescRight">Returns the standard C threeway comparison between cmp(lhs, rhs) between two string views.  <br /></td></tr>
<tr class="separator:a688dcdc0c6fe3901d71d114ad699c765"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:af7d6a7d0e99847c09f13183a84ced42e"><td class="memItemLeft" align="right" valign="top"><a class="el" href="str__view_8h.html#ab632a39b679bbed9a2f8a8cbb6c04807">SV_API</a> <a class="el" href="str__view_8h.html#a648d7dfc8555055b2e5b742d0aa6fdf7">SV_Order</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="str__view_8h.html#af7d6a7d0e99847c09f13183a84ced42e">SV_terminated_compare</a> (<a class="el" href="structSV__Str__view.html">SV_Str_view</a> lhs, char const *rhs) <a class="el" href="str__view_8h.html#a15ca829e06962ad8c8c690db021ba2ef">SV_ATTRIB_NULLTERM</a>(2) <a class="el" href="str__view_8h.html#a8bc45837a6af4c6f8a18d674626bbe34">SV_ATTRIB_PURE</a></td></tr>
<tr class="memdesc:af7d6a7d0e99847c09f13183a84ced42e"><td class="mdescLeft">&#160;</td><td class="mdescRight">Returns the standard C threeway comparison between cmp(lhs, rhs) between a <a class="el" href="structSV__Str__view.html" title="A read-only view of string data in C.">SV_Str_view</a> and a C string.  <br /></td></tr>
<tr class="separator:af7d6a7d0e99847c09f13183a84ced42e"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a6c9c796c96c8fd907aefee8e5a875c20"><td class="memItemLeft" align="right" valign="top"><a class="el" href="str__view_8h.html#ab632a39b679bbed9a2f8a8cbb6c04807">SV_API</a> <a class="el" href="str__view_8h.html#a648d7dfc8555055b2e5b742d0aa6fdf7">SV_Order</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="str__view_8h.html#a6c9c796c96c8fd907aefee8e5a875c20">SV_view_compare</a> (<a class="el" href="structSV__Str__view.html">SV_Str_view</a> lhs, char const *rhs, size_t n) <a class="el" href="str__view_8h.html#a15ca829e06962ad8c8c690db021ba2ef">SV_ATTRIB_NULLTERM</a>(2) <a class="el" href="str__view_8h.html#a8bc45837a6af4c6f8a18d674626bbe34">SV_ATTRIB_PURE</a></td></tr>
<tr class="memdesc:a6c9c796c96c8fd907aefee8e5a875c20"><td class="mdescLeft">&#160;</td><td class="mdescRight">Returns the standard C threeway comparison between cmp(lhs, rhs) between a <a class="el" href="structSV__Str__view.html" title="A read-only view of string data in C.">SV_Str_view</a> and a C string, bounded by n bytes of the right hand side. If <code>n</code> is shorter than the right hand side string the <code>n</code>th byte is compared.  <br /></td></tr>
<tr class="separator:a6c9c796c96c8fd907aefee8e5a875c20"><td class="memSeparator" colspan="2">&#160;</td></tr>
</table><table class="memberdecls">
<tr class="heading"><td colspan="2"><h2 class="groupheader">Tokenization and Iteration</h2></td></tr>
<tr><td class="ititle" colspan="2"><p>Tokenize a <code><a class="el" href="structSV__Str__view.html" title="A read-only view of string data in C.">SV_Str_view</a></code> and use convenient iteration abstractions. </p>
</td></tr>
<tr class="memitem:a62b250077ad955f6625508c890f2661f"><td class="memItemLeft" align="right" valign="top"><a class="el" href="str__view_8h.html#ab632a39b679bbed9a2f8a8cbb6c04807">SV_API</a> <a class="el" href="structSV__Str__view.html">SV_Str_view</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="str__view_8h.html#a62b250077ad955f6625508c890f2661f">SV_token_begin</a> (<a class="el" href="structSV__Str__view.html">SV_Str_view</a> src, <a class="el" href="structSV__Str__view.html">SV_Str_view</a> delim) <a class="el" href="str__view_8h.html#a8bc45837a6af4c6f8a18d674626bbe34">SV_ATTRIB_PURE</a></td></tr>
<tr class="memdesc:a62b250077ad955f6625508c890f2661f"><td class="mdescLeft">&#160;</td><td class="mdescRight">Finds the first tokenized position in the string view given any length delim <a class="el" href="structSV__Str__view.html" title="A read-only view of string data in C.">SV_Str_view</a>.  <br /></td></tr>
<tr class="separator:a62b250077ad955f6625508c890f2661f"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a405f4d6a75078d52dd7ebb38877796e0"><td class="memItemLeft" align="right" valign="top"><a class="el" href="str__view_8h.html#ab632a39b679bbed9a2f8a8cbb6c04807">SV_API</a> bool&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="str__view_8h.html#a405f4d6a75078d52dd7ebb38877796e0">SV_token_end</a> (<a class="el" href="structSV__Str__view.html">SV_Str_view</a> src, <a class="el" href="structSV__Str__view.html">SV_Str_view</a> token) <a class="el" href="str__view_8h.html#a8bc45837a6af4c6f8a18d674626bbe34">SV_ATTRIB_PURE</a></td></tr>
<tr class="memdesc:a405f4d6a75078d52dd7ebb38877796e0"><td class="mdescLeft">&#160;</td><td class="mdescRight">Provides the status of the current tokenization for use in conditions such as loops.  <br /></td></tr>
<tr class="separator:a405f4d6a75078d52dd7ebb38877796e0"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a4e6cb5dcc148fd82026f194299ebbe32"><td class="memItemLeft" align="right" valign="top"><a class="el" href="str__view_8h.html#ab632a39b679bbed9a2f8a8cbb6c04807">SV_API</a> <a class="el" href="structSV__Str__view.html">SV_Str_view</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="str__view_8h.html#a4e6cb5dcc148fd82026f194299ebbe32">SV_token_next</a> (<a class="el" href="structSV__Str__view.html">SV_Str_view</a> src, <a class="el" href="structSV__Str__view.html">SV_Str_view</a> token, <a class="el" href="structSV__Str__view.html">SV_Str_view</a> delim) <a class="el" href="str__view_8h.html#a8bc45837a6af4c6f8a18d674626bbe34">SV_ATTRIB_PURE</a></td></tr>
<tr class="memdesc:a4e6cb5dcc148fd82026f194299ebbe32"><td class="mdescLeft">&#160;</td><td class="mdescRight">Advances to the next token in the remaining view separated by the delim.  <br /></td></tr>
<tr class="separator:a4e6cb5dcc148fd82026f194299ebbe32"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ac68c938032a96116e93902e9e9d749da"><td class="memItemLeft" align="right" valign="top"><a class="el" href="str__view_8h.html#ab632a39b679bbed9a2f8a8cbb6c04807">SV_API</a> <a class="el" href="structSV__Str__view.html">SV_Str_view</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="str__view_8h.html#ac68c938032a96116e93902e9e9d749da">SV_token_reverse_begin</a> (<a class="el" href="structSV__Str__view.html">SV_Str_view</a> src, <a class="el" href="structSV__Str__view.html">SV_Str_view</a> delim) <a class="el" href="str__view_8h.html#a8bc45837a6af4c6f8a18d674626bbe34">SV_ATTRIB_PURE</a></td></tr>
<tr class="separator:ac68c938032a96116e93902e9e9d749da"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a75dcc72fda448d3ca49789a8efbe95f9"><td class="memItemLeft" align="right" valign="top"><a class="el" href="str__view_8h.html#ab632a39b679bbed9a2f8a8cbb6c04807">SV_API</a> bool&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="str__view_8h.html#a75dcc72fda448d3ca49789a8efbe95f9">SV_token_reverse_end</a> (<a class="el" href="structSV__Str__view.html">SV_Str_view</a> src, <a class="el" href="structSV__Str__view.html">SV_Str_view</a> token) <a class="el" href="str__view_8h.html#a8bc45837a6af4c6f8a18d674626bbe34">SV_ATTRIB_PURE</a></td></tr>
<tr class="memdesc:a75dcc72fda448d3ca49789a8efbe95f9"><td class="mdescLeft">&#160;</td><td class="mdescRight">Provides the status of the current tokenization for use in conditions such as loops.  <br /></td></tr>
<tr class="separator:a75dcc72fda448d3ca49789a8efbe95f9"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a655161c9c6e475c7da280d622c63740a"><td class="memItemLeft" align="right" valign="top"><a class="el" href="str__view_8h.html#ab632a39b679bbed9a2f8a8cbb6c04807">SV_API</a> <a class="el" href="structSV__Str__view.html">SV_Str_view</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="str__view_8h.html#a655161c9c6e475c7da280d622c63740a">SV_token_reverse_next</a> (<a class="el" href="structSV__Str__view.html">SV_Str_view</a> src, <a class="el" href="structSV__Str__view.html">SV_Str_view</a> token, <a class="el" href="structSV__Str__view.html">SV_Str_view</a> delim) <a class="el" href="str__view_8h.html#a8bc45837a6af4c6f8a18d674626bbe34">SV_ATTRIB_PURE</a></td></tr>
<tr class="memdesc:a655161c9c6e475c7da280d622c63740a"><td class="mdescLeft">&#160;</td><td class="mdescRight">Advances the token in src to the next token between two delimiters provided by delim.  <br /></td></tr>
<tr class="separator:a655161c9c6e475c7da280d622c63740a"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a46e8ee9b18ff6110dc8ec907442c8616"><td class="memItemLeft" align="right" valign="top"><a class="el" href="str__view_8h.html#ab632a39b679bbed9a2f8a8cbb6c04807">SV_API</a> char const *&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="str__view_8h.html#a46e8ee9b18ff6110dc8ec907442c8616">SV_begin</a> (<a class="el" href="structSV__Str__view.html">SV_Str_view</a> sv) <a class="el" href="str__view_8h.html#a8bc45837a6af4c6f8a18d674626bbe34">SV_ATTRIB_PURE</a></td></tr>
<tr class="memdesc:a46e8ee9b18ff6110dc8ec907442c8616"><td class="mdescLeft">&#160;</td><td class="mdescRight">Returns a read only pointer to the beginning of the string view, the first valid character in the view.  <br /></td></tr>
<tr class="separator:a46e8ee9b18ff6110dc8ec907442c8616"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a138480842acd552567d9ad95c83cb71c"><td class="memItemLeft" align="right" valign="top"><a class="el" href="str__view_8h.html#ab632a39b679bbed9a2f8a8cbb6c04807">SV_API</a> char const *&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="str__view_8h.html#a138480842acd552567d9ad95c83cb71c">SV_reverse_begin</a> (<a class="el" href="structSV__Str__view.html">SV_Str_view</a> sv) <a class="el" href="str__view_8h.html#a8bc45837a6af4c6f8a18d674626bbe34">SV_ATTRIB_PURE</a></td></tr>
<tr class="memdesc:a138480842acd552567d9ad95c83cb71c"><td class="mdescLeft">&#160;</td><td class="mdescRight">Returns the reverse iterator beginning, the last character of the current view.  <br /></td></tr>
<tr class="separator:a138480842acd552567d9ad95c83cb71c"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a8f9fa408933690832b2ae4df3643167a"><td class="memItemLeft" align="right" valign="top"><a class="el" href="str__view_8h.html#ab632a39b679bbed9a2f8a8cbb6c04807">SV_API</a> char const *&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="str__view_8h.html#a8f9fa408933690832b2ae4df3643167a">SV_next</a> (char const *c) <a class="el" href="str__view_8h.html#a15ca829e06962ad8c8c690db021ba2ef">SV_ATTRIB_NULLTERM</a>(1) <a class="el" href="str__view_8h.html#a8bc45837a6af4c6f8a18d674626bbe34">SV_ATTRIB_PURE</a></td></tr>
<tr class="memdesc:a8f9fa408933690832b2ae4df3643167a"><td class="mdescLeft">&#160;</td><td class="mdescRight">Advances the null terminated string pointer from its previous position. If NULL is provided <a class="el" href="str__view_8h.html#a7dcc45b3e74f7e8b64d825268ffacba7" title="A sentinel empty string. Safely dereference to view a null terminator. This may be returned from vari...">SV_null()</a> is returned.  <br /></td></tr>
<tr class="separator:a8f9fa408933690832b2ae4df3643167a"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a36a2d227f439ab73152a172cca2150aa"><td class="memItemLeft" align="right" valign="top"><a class="el" href="str__view_8h.html#ab632a39b679bbed9a2f8a8cbb6c04807">SV_API</a> char const *&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="str__view_8h.html#a36a2d227f439ab73152a172cca2150aa">SV_reverse_next</a> (char const *c) <a class="el" href="str__view_8h.html#a8bc45837a6af4c6f8a18d674626bbe34">SV_ATTRIB_PURE</a></td></tr>
<tr class="memdesc:a36a2d227f439ab73152a172cca2150aa"><td class="mdescLeft">&#160;</td><td class="mdescRight">Advances the iterator to the next character in the <a class="el" href="structSV__Str__view.html" title="A read-only view of string data in C.">SV_Str_view</a> being iterated through in reverse.  <br /></td></tr>
<tr class="separator:a36a2d227f439ab73152a172cca2150aa"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a6951dd73c6c8828691ed6086ceb373d9"><td class="memItemLeft" align="right" valign="top"><a class="el" href="str__view_8h.html#ab632a39b679bbed9a2f8a8cbb6c04807">SV_API</a> char const *&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="str__view_8h.html#a6951dd73c6c8828691ed6086ceb373d9">SV_end</a> (<a class="el" href="structSV__Str__view.html">SV_Str_view</a> sv) <a class="el" href="str__view_8h.html#a8bc45837a6af4c6f8a18d674626bbe34">SV_ATTRIB_PURE</a></td></tr>
<tr class="memdesc:a6951dd73c6c8828691ed6086ceb373d9"><td class="mdescLeft">&#160;</td><td class="mdescRight">Returns a read only pointer to the end of the string view.  <br /></td></tr>
<tr class="separator:a6951dd73c6c8828691ed6086ceb373d9"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a5cbbc03e7e0fbc110b66e5b5458d3e47"><td class="memItemLeft" align="right" valign="top"><a class="el" href="str__view_8h.html#ab632a39b679bbed9a2f8a8cbb6c04807">SV_API</a> char const *&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="str__view_8h.html#a5cbbc03e7e0fbc110b66e5b5458d3e47">SV_reverse_end</a> (<a class="el" href="structSV__Str__view.html">SV_Str_view</a> sv) <a class="el" href="str__view_8h.html#a8bc45837a6af4c6f8a18d674626bbe34">SV_ATTRIB_PURE</a></td></tr>
<tr class="memdesc:a5cbbc03e7e0fbc110b66e5b5458d3e47"><td class="mdescLeft">&#160;</td><td class="mdescRight">The ending position of a reverse iteration.  <br /></td></tr>
<tr class="separator:a5cbbc03e7e0fbc110b66e5b5458d3e47"><td class="memSeparator" colspan="2">&#160;</td></tr>
</table><table class="memberdecls">
<tr class="heading"><td colspan="2"><h2 class="groupheader">String Matching</h2></td></tr>
<tr><td class="ititle" colspan="2"><p>Search a <code><a class="el" href="structSV__Str__view.html" title="A read-only view of string data in C.">SV_Str_view</a></code> for various types of substrings and character matches. </p>
</td></tr>
<tr class="memitem:a93a55d034c1de8b45d51fcb22e879600"><td class="memItemLeft" align="right" valign="top"><a class="el" href="str__view_8h.html#ab632a39b679bbed9a2f8a8cbb6c04807">SV_API</a> size_t&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="str__view_8h.html#a93a55d034c1de8b45d51fcb22e879600">SV_find</a> (<a class="el" href="structSV__Str__view.html">SV_Str_view</a> haystack, size_t pos, <a class="el" href="structSV__Str__view.html">SV_Str_view</a> needle) <a class="el" href="str__view_8h.html#a8bc45837a6af4c6f8a18d674626bbe34">SV_ATTRIB_PURE</a></td></tr>
<tr class="memdesc:a93a55d034c1de8b45d51fcb22e879600"><td class="mdescLeft">&#160;</td><td class="mdescRight">Searches for needle in haystack starting from pos.  <br /></td></tr>
<tr class="separator:a93a55d034c1de8b45d51fcb22e879600"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a3b1ee28c15cef81bfe06294ca2a90421"><td class="memItemLeft" align="right" valign="top"><a class="el" href="str__view_8h.html#ab632a39b679bbed9a2f8a8cbb6c04807">SV_API</a> size_t&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="str__view_8h.html#a3b1ee28c15cef81bfe06294ca2a90421">SV_reverse_find</a> (<a class="el" href="structSV__Str__view.html">SV_Str_view</a> haystack, size_t pos, <a class="el" href="structSV__Str__view.html">SV_Str_view</a> needle) <a class="el" href="str__view_8h.html#a8bc45837a6af4c6f8a18d674626bbe34">SV_ATTRIB_PURE</a></td></tr>
<tr class="memdesc:a3b1ee28c15cef81bfe06294ca2a90421"><td class="mdescLeft">&#160;</td><td class="mdescRight">Searches for the last occurrence of needle in haystack starting from pos from right to left.  <br /></td></tr>
<tr class="separator:a3b1ee28c15cef81bfe06294ca2a90421"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:abda3bd093b8f513f8d299b09e3894aa5"><td class="memItemLeft" align="right" valign="top"><a class="el" href="str__view_8h.html#ab632a39b679bbed9a2f8a8cbb6c04807">SV_API</a> bool&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="str__view_8h.html#abda3bd093b8f513f8d299b09e3894aa5">SV_contains</a> (<a class="el" href="structSV__Str__view.html">SV_Str_view</a> haystack, <a class="el" href="structSV__Str__view.html">SV_Str_view</a> needle) <a class="el" href="str__view_8h.html#a8bc45837a6af4c6f8a18d674626bbe34">SV_ATTRIB_PURE</a></td></tr>
<tr class="memdesc:abda3bd093b8f513f8d299b09e3894aa5"><td class="mdescLeft">&#160;</td><td class="mdescRight">Tests membership of needle in haystack.  <br /></td></tr>
<tr class="separator:abda3bd093b8f513f8d299b09e3894aa5"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ac5c032d8aef68920426ed01818a9ebf0"><td class="memItemLeft" align="right" valign="top"><a class="el" href="str__view_8h.html#ab632a39b679bbed9a2f8a8cbb6c04807">SV_API</a> <a class="el" href="structSV__Str__view.html">SV_Str_view</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="str__view_8h.html#ac5c032d8aef68920426ed01818a9ebf0">SV_match</a> (<a class="el" href="structSV__Str__view.html">SV_Str_view</a> haystack, <a class="el" href="structSV__Str__view.html">SV_Str_view</a> needle) <a class="el" href="str__view_8h.html#a8bc45837a6af4c6f8a18d674626bbe34">SV_ATTRIB_PURE</a></td></tr>
<tr class="memdesc:ac5c032d8aef68920426ed01818a9ebf0"><td class="mdescLeft">&#160;</td><td class="mdescRight">Search for a substring within a source string view.  <br /></td></tr>
<tr class="separator:ac5c032d8aef68920426ed01818a9ebf0"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a77a42a2acef5e7a57516d0eb78cc338e"><td class="memItemLeft" align="right" valign="top"><a class="el" href="str__view_8h.html#ab632a39b679bbed9a2f8a8cbb6c04807">SV_API</a> <a class="el" href="structSV__Str__view.html">SV_Str_view</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="str__view_8h.html#a77a42a2acef5e7a57516d0eb78cc338e">SV_reverse_match</a> (<a class="el" href="structSV__Str__view.html">SV_Str_view</a> haystack, <a class="el" href="structSV__Str__view.html">SV_Str_view</a> needle) <a class="el" href="str__view_8h.html#a8bc45837a6af4c6f8a18d674626bbe34">SV_ATTRIB_PURE</a></td></tr>
<tr class="memdesc:a77a42a2acef5e7a57516d0eb78cc338e"><td class="mdescLeft">&#160;</td><td class="mdescRight">Search for a substring within a source string in reverse.  <br /></td></tr>
<tr class="separator:a77a42a2acef5e7a57516d0eb78cc338e"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ae1ed256cc213d1c5ce599a80095f13e8"><td class="memItemLeft" align="right" valign="top"><a class="el" href="str__view_8h.html#ab632a39b679bbed9a2f8a8cbb6c04807">SV_API</a> bool&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="str__view_8h.html#ae1ed256cc213d1c5ce599a80095f13e8">SV_starts_with</a> (<a class="el" href="structSV__Str__view.html">SV_Str_view</a> sv, <a class="el" href="structSV__Str__view.html">SV_Str_view</a> prefix) <a class="el" href="str__view_8h.html#a8bc45837a6af4c6f8a18d674626bbe34">SV_ATTRIB_PURE</a></td></tr>
<tr class="memdesc:ae1ed256cc213d1c5ce599a80095f13e8"><td class="mdescLeft">&#160;</td><td class="mdescRight">Confirms the presence of a prefix within a string view.  <br /></td></tr>
<tr class="separator:ae1ed256cc213d1c5ce599a80095f13e8"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a55d65ba65e53a6b4cebac2bc8f20d260"><td class="memItemLeft" align="right" valign="top"><a class="el" href="str__view_8h.html#ab632a39b679bbed9a2f8a8cbb6c04807">SV_API</a> <a class="el" href="structSV__Str__view.html">SV_Str_view</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="str__view_8h.html#a55d65ba65e53a6b4cebac2bc8f20d260">SV_remove_prefix</a> (<a class="el" href="structSV__Str__view.html">SV_Str_view</a> sv, size_t n) <a class="el" href="str__view_8h.html#a8bc45837a6af4c6f8a18d674626bbe34">SV_ATTRIB_PURE</a></td></tr>
<tr class="separator:a55d65ba65e53a6b4cebac2bc8f20d260"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a4a51df59030495220376ee055dc6475b"><td class="memItemLeft" align="right" valign="top"><a class="el" href="str__view_8h.html#ab632a39b679bbed9a2f8a8cbb6c04807">SV_API</a> bool&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="str__view_8h.html#a4a51df59030495220376ee055dc6475b">SV_ends_with</a> (<a class="el" href="structSV__Str__view.html">SV_Str_view</a> sv, <a class="el" href="structSV__Str__view.html">SV_Str_view</a> suffix) <a class="el" href="str__view_8h.html#a8bc45837a6af4c6f8a18d674626bbe34">SV_ATTRIB_PURE</a></td></tr>
<tr class="memdesc:a4a51df59030495220376ee055dc6475b"><td class="mdescLeft">&#160;</td><td class="mdescRight">Confirms the presence of a suffix within a string view.  <br /></td></tr>
<tr class="separator:a4a51df59030495220376ee055dc6475b"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:aaed44c202a2e11978aca3d06877a00db"><td class="memItemLeft" align="right" valign="top"><a class="el" href="str__view_8h.html#ab632a39b679bbed9a2f8a8cbb6c04807">SV_API</a> <a class="el" href="structSV__Str__view.html">SV_Str_view</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="str__view_8h.html#aaed44c202a2e11978aca3d06877a00db">SV_remove_suffix</a> (<a class="el" href="structSV__Str__view.html">SV_Str_view</a> sv, size_t n) <a class="el" href="str__view_8h.html#a8bc45837a6af4c6f8a18d674626bbe34">SV_ATTRIB_PURE</a></td></tr>
<tr class="separator:aaed44c202a2e11978aca3d06877a00db"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ad7419870318b8657fe00ce5fb7889b6a"><td class="memItemLeft" align="right" valign="top"><a class="el" href="str__view_8h.html#ab632a39b679bbed9a2f8a8cbb6c04807">SV_API</a> size_t&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="str__view_8h.html#ad7419870318b8657fe00ce5fb7889b6a">SV_find_first_of</a> (<a class="el" href="structSV__Str__view.html">SV_Str_view</a> haystack, <a class="el" href="structSV__Str__view.html">SV_Str_view</a> set) <a class="el" href="str__view_8h.html#a8bc45837a6af4c6f8a18d674626bbe34">SV_ATTRIB_PURE</a></td></tr>
<tr class="separator:ad7419870318b8657fe00ce5fb7889b6a"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:aa05019727da818cc4bc585ed3d7ae32c"><td class="memItemLeft" align="right" valign="top"><a class="el" href="str__view_8h.html#ab632a39b679bbed9a2f8a8cbb6c04807">SV_API</a> size_t&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="str__view_8h.html#aa05019727da818cc4bc585ed3d7ae32c">SV_find_first_not_of</a> (<a class="el" href="structSV__Str__view.html">SV_Str_view</a> haystack, <a class="el" href="structSV__Str__view.html">SV_Str_view</a> set) <a class="el" href="str__view_8h.html#a8bc45837a6af4c6f8a18d674626bbe34">SV_ATTRIB_PURE</a></td></tr>
<tr class="separator:aa05019727da818cc4bc585ed3d7ae32c"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:aeff05fad09dde73aeab519cbce425396"><td class="memItemLeft" align="right" valign="top"><a class="el" href="str__view_8h.html#ab632a39b679bbed9a2f8a8cbb6c04807">SV_API</a> size_t&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="str__view_8h.html#aeff05fad09dde73aeab519cbce425396">SV_find_last_of</a> (<a class="el" href="structSV__Str__view.html">SV_Str_view</a> haystack, <a class="el" href="structSV__Str__view.html">SV_Str_view</a> set) <a class="el" href="str__view_8h.html#a8bc45837a6af4c6f8a18d674626bbe34">SV_ATTRIB_PURE</a></td></tr>
<tr class="separator:aeff05fad09dde73aeab519cbce425396"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:aa5ea35766e4fdb45a0724f46f7d159fd"><td class="memItemLeft" align="right" valign="top"><a class="el" href="str__view_8h.html#ab632a39b679bbed9a2f8a8cbb6c04807">SV_API</a> size_t&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="str__view_8h.html#aa5ea35766e4fdb45a0724f46f7d159fd">SV_find_last_not_of</a> (<a class="el" href="structSV__Str__view.html">SV_Str_view</a> haystack, <a class="el" href="structSV__Str__view.html">SV_Str_view</a> set) <a class="el" href="str__view_8h.html#a8bc45837a6af4c6f8a18d674626bbe34">SV_ATTRIB_PURE</a></td></tr>
<tr class="separator:aa5ea35766e4fdb45a0724f46f7d159fd"><td class="memSeparator" colspan="2">&#160;</td></tr>
</table><table class="memberdecls">
<tr class="heading"><td colspan="2"><h2 class="groupheader">State</h2></td></tr>
<tr><td class="ititle" colspan="2"><p>Obtain current state of an <code><a class="el" href="structSV__Str__view.html" title="A read-only view of string data in C.">SV_Str_view</a></code> and C strings. </p>
</td></tr>
<tr class="memitem:abb04b423a7122b27cd6ea12dd78a0134"><td class="memItemLeft" align="right" valign="top"><a class="el" href="str__view_8h.html#ab632a39b679bbed9a2f8a8cbb6c04807">SV_API</a> size_t&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="str__view_8h.html#abb04b423a7122b27cd6ea12dd78a0134">SV_min_len</a> (char const *str, size_t n) <a class="el" href="str__view_8h.html#a15ca829e06962ad8c8c690db021ba2ef">SV_ATTRIB_NULLTERM</a>(1) <a class="el" href="str__view_8h.html#a8bc45837a6af4c6f8a18d674626bbe34">SV_ATTRIB_PURE</a></td></tr>
<tr class="memdesc:abb04b423a7122b27cd6ea12dd78a0134"><td class="mdescLeft">&#160;</td><td class="mdescRight">Returns the minimum between the string size vs n bytes.  <br /></td></tr>
<tr class="separator:abb04b423a7122b27cd6ea12dd78a0134"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a7dcc45b3e74f7e8b64d825268ffacba7"><td class="memItemLeft" align="right" valign="top"><a class="el" href="str__view_8h.html#ab632a39b679bbed9a2f8a8cbb6c04807">SV_API</a> char const *&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="str__view_8h.html#a7dcc45b3e74f7e8b64d825268ffacba7">SV_null</a> (void) <a class="el" href="str__view_8h.html#a8bc45837a6af4c6f8a18d674626bbe34">SV_ATTRIB_PURE</a></td></tr>
<tr class="memdesc:a7dcc45b3e74f7e8b64d825268ffacba7"><td class="mdescLeft">&#160;</td><td class="mdescRight">A sentinel empty string. Safely dereference to view a null terminator. This may be returned from various functions when bad input is given such as NULL pointers as the underlying <a class="el" href="structSV__Str__view.html" title="A read-only view of string data in C.">SV_Str_view</a> string pointer.  <br /></td></tr>
<tr class="separator:a7dcc45b3e74f7e8b64d825268ffacba7"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ada02c23f45597bf76446a8ca3ce22983"><td class="memItemLeft" align="right" valign="top"><a class="el" href="str__view_8h.html#ab632a39b679bbed9a2f8a8cbb6c04807">SV_API</a> size_t&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="str__view_8h.html#ada02c23f45597bf76446a8ca3ce22983">SV_npos</a> (<a class="el" href="structSV__Str__view.html">SV_Str_view</a> sv) <a class="el" href="str__view_8h.html#aa8df9c93f659cdd2543c3c1f11236bb4">SV_ATTRIB_CONST</a></td></tr>
<tr class="memdesc:ada02c23f45597bf76446a8ca3ce22983"><td class="mdescLeft">&#160;</td><td class="mdescRight">The end of a <a class="el" href="structSV__Str__view.html" title="A read-only view of string data in C.">SV_Str_view</a> guaranteed to be greater than or equal to size.  <br /></td></tr>
<tr class="separator:ada02c23f45597bf76446a8ca3ce22983"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a9bbd790f94c692b9414e2f66208aaf38"><td class="memItemLeft" align="right" valign="top"><a class="el" href="str__view_8h.html#ab632a39b679bbed9a2f8a8cbb6c04807">SV_API</a> bool&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="str__view_8h.html#a9bbd790f94c692b9414e2f66208aaf38">SV_is_empty</a> (<a class="el" href="structSV__Str__view.html">SV_Str_view</a> sv) <a class="el" href="str__view_8h.html#aa8df9c93f659cdd2543c3c1f11236bb4">SV_ATTRIB_CONST</a></td></tr>
<tr class="memdesc:a9bbd790f94c692b9414e2f66208aaf38"><td class="mdescLeft">&#160;</td><td class="mdescRight">Returns true if the provided <a class="el" href="structSV__Str__view.html" title="A read-only view of string data in C.">SV_Str_view</a> is empty, false otherwise.  <br /></td></tr>
<tr class="separator:a9bbd790f94c692b9414e2f66208aaf38"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a4212c23637ecd0ca93539cec3967d080"><td class="memItemLeft" align="right" valign="top"><a class="el" href="str__view_8h.html#ab632a39b679bbed9a2f8a8cbb6c04807">SV_API</a> size_t&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="str__view_8h.html#a4212c23637ecd0ca93539cec3967d080">SV_len</a> (<a class="el" href="structSV__Str__view.html">SV_Str_view</a> sv) <a class="el" href="str__view_8h.html#aa8df9c93f659cdd2543c3c1f11236bb4">SV_ATTRIB_CONST</a></td></tr>
<tr class="memdesc:a4212c23637ecd0ca93539cec3967d080"><td class="mdescLeft">&#160;</td><td class="mdescRight">Returns the length of the <a class="el" href="structSV__Str__view.html" title="A read-only view of string data in C.">SV_Str_view</a> in O(1) time.  <br /></td></tr>
<tr class="separator:a4212c23637ecd0ca93539cec3967d080"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ab343394ad4ab6d05bef0793faf11c2df"><td class="memItemLeft" align="right" valign="top"><a class="el" href="str__view_8h.html#ab632a39b679bbed9a2f8a8cbb6c04807">SV_API</a> size_t&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="str__view_8h.html#ab343394ad4ab6d05bef0793faf11c2df">SV_bytes</a> (<a class="el" href="structSV__Str__view.html">SV_Str_view</a> sv) <a class="el" href="str__view_8h.html#aa8df9c93f659cdd2543c3c1f11236bb4">SV_ATTRIB_CONST</a></td></tr>
<tr class="separator:ab343394ad4ab6d05bef0793faf11c2df"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a273d93cb03aafaf8722e850b98fd2e0a"><td class="memItemLeft" align="right" valign="top"><a class="el" href="str__view_8h.html#ab632a39b679bbed9a2f8a8cbb6c04807">SV_API</a> char const *&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="str__view_8h.html#a273d93cb03aafaf8722e850b98fd2e0a">SV_pointer</a> (<a class="el" href="structSV__Str__view.html">SV_Str_view</a> sv, size_t i) <a class="el" href="str__view_8h.html#a8bc45837a6af4c6f8a18d674626bbe34">SV_ATTRIB_PURE</a></td></tr>
<tr class="memdesc:a273d93cb03aafaf8722e850b98fd2e0a"><td class="mdescLeft">&#160;</td><td class="mdescRight">Returns the character pointer at the minimum between the indicated position and the end of the string view.  <br /></td></tr>
<tr class="separator:a273d93cb03aafaf8722e850b98fd2e0a"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ac5a6ed7644fef209bbb1348688798bf0"><td class="memItemLeft" align="right" valign="top"><a class="el" href="str__view_8h.html#ab632a39b679bbed9a2f8a8cbb6c04807">SV_API</a> char&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="str__view_8h.html#ac5a6ed7644fef209bbb1348688798bf0">SV_at</a> (<a class="el" href="structSV__Str__view.html">SV_Str_view</a> sv, size_t i) <a class="el" href="str__view_8h.html#a8bc45837a6af4c6f8a18d674626bbe34">SV_ATTRIB_PURE</a></td></tr>
<tr class="memdesc:ac5a6ed7644fef209bbb1348688798bf0"><td class="mdescLeft">&#160;</td><td class="mdescRight">Obtain a character at a position in the string view.  <br /></td></tr>
<tr class="separator:ac5a6ed7644fef209bbb1348688798bf0"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:aedcbc80e6658730cc9cf17f9cddeb351"><td class="memItemLeft" align="right" valign="top"><a class="el" href="str__view_8h.html#ab632a39b679bbed9a2f8a8cbb6c04807">SV_API</a> char&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="str__view_8h.html#aedcbc80e6658730cc9cf17f9cddeb351">SV_front</a> (<a class="el" href="structSV__Str__view.html">SV_Str_view</a> sv) <a class="el" href="str__view_8h.html#a8bc45837a6af4c6f8a18d674626bbe34">SV_ATTRIB_PURE</a></td></tr>
<tr class="memdesc:aedcbc80e6658730cc9cf17f9cddeb351"><td class="mdescLeft">&#160;</td><td class="mdescRight">Obtain the character at the first position of <a class="el" href="structSV__Str__view.html" title="A read-only view of string data in C.">SV_Str_view</a>.  <br /></td></tr>
<tr class="separator:aedcbc80e6658730cc9cf17f9cddeb351"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a035cd674c3935cc96aeac032d4db9485"><td class="memItemLeft" align="right" valign="top"><a class="el" href="str__view_8h.html#ab632a39b679bbed9a2f8a8cbb6c04807">SV_API</a> char&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="str__view_8h.html#a035cd674c3935cc96aeac032d4db9485">SV_back</a> (<a class="el" href="structSV__Str__view.html">SV_Str_view</a> sv) <a class="el" href="str__view_8h.html#a8bc45837a6af4c6f8a18d674626bbe34">SV_ATTRIB_PURE</a></td></tr>
<tr class="memdesc:a035cd674c3935cc96aeac032d4db9485"><td class="mdescLeft">&#160;</td><td class="mdescRight">Obtain the character at the last position of <a class="el" href="structSV__Str__view.html" title="A read-only view of string data in C.">SV_Str_view</a>.  <br /></td></tr>
<tr class="separator:a035cd674c3935cc96aeac032d4db9485"><td class="memSeparator" colspan="2">&#160;</td></tr>
</table>
<h2 class="groupheader">Macro Definition Documentation</h2>
<a id="ab735680cc4059381ce2cad6c8fc690d3" name="ab735680cc4059381ce2cad6c8fc690d3"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ab735680cc4059381ce2cad6c8fc690d3">&#9670;&#160;</a></span>SV_from</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">#define SV_from</td>
          <td>(</td>
          <td class="paramtype">&#160;</td>
          <td class="paramname">str_literal</td><td>)</td>
          <td>&#160;&#160;&#160;    ((<a class="el" href="structSV__Str__view.html">SV_Str_view</a>){<a class="el" href="str__view_8h.html#a6efdaade95a9e224ba814c928204e4dc">SV_STR_LITERAL</a>(str_literal), sizeof(str_literal) - 1})</td>
        </tr>
      </table>
</div><div class="memdoc">

<p>A macro to reduce the chance for errors in repeating oneself when constructing an inline or const <a class="el" href="structSV__Str__view.html" title="A read-only view of string data in C.">SV_Str_view</a>. The input must be a string literal. </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramdir">[in]</td><td class="paramname">str_literal</td><td>a C string literal </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>a string view constructed in O(1) at compile time. For example:</dd></dl>
<div class="fragment"><div class="line"><span class="keyword">static</span> <a class="code hl_struct" href="structSV__Str__view.html">SV_Str_view</a> <span class="keyword">const</span> prefix = <a class="code hl_define" href="str__view_8h.html#ab735680cc4059381ce2cad6c8fc690d3">SV_from</a>(<span class="stringliteral">&quot;test_&quot;</span>);</div>
<div class="ttc" id="astr__view_8h_html_ab735680cc4059381ce2cad6c8fc690d3"><div class="ttname"><a href="str__view_8h.html#ab735680cc4059381ce2cad6c8fc690d3">SV_from</a></div><div class="ttdeci">#define SV_from(str_literal)</div><div class="ttdoc">A macro to reduce the chance for errors in repeating oneself when constructing an inline or const SV_...</div><div class="ttdef"><b>Definition:</b> str_view.h:171</div></div>
<div class="ttc" id="astructSV__Str__view_html"><div class="ttname"><a href="structSV__Str__view.html">SV_Str_view</a></div><div class="ttdoc">A read-only view of string data in C.</div><div class="ttdef"><b>Definition:</b> str_view.h:124</div></div>
</div><!-- fragment --><p>One can even use this in code when string literals are used rather than saved constants to avoid errors in <a class="el" href="structSV__Str__view.html" title="A read-only view of string data in C.">SV_Str_view</a> constructions.</p>
<div class="fragment"><div class="line"><span class="keywordflow">for</span> (<a class="code hl_struct" href="structSV__Str__view.html">SV_Str_view</a> cur = <a class="code hl_function" href="str__view_8h.html#a62b250077ad955f6625508c890f2661f">SV_token_begin</a>(src, <a class="code hl_define" href="str__view_8h.html#ab735680cc4059381ce2cad6c8fc690d3">SV_from</a>(<span class="stringliteral">&quot; &quot;</span>));</div>
<div class="line">    !<a class="code hl_function" href="str__view_8h.html#a405f4d6a75078d52dd7ebb38877796e0">SV_token_end</a>(src, cur);</div>
<div class="line">    cur = <a class="code hl_function" href="str__view_8h.html#a4e6cb5dcc148fd82026f194299ebbe32">SV_token_next</a>(src, cur, <a class="code hl_define" href="str__view_8h.html#ab735680cc4059381ce2cad6c8fc690d3">SV_from</a>(<span class="stringliteral">&quot; &quot;</span>))</div>
<div class="line">{}</div>
<div class="ttc" id="astr__view_8h_html_a405f4d6a75078d52dd7ebb38877796e0"><div class="ttname"><a href="str__view_8h.html#a405f4d6a75078d52dd7ebb38877796e0">SV_token_end</a></div><div class="ttdeci">SV_API bool SV_token_end(SV_Str_view src, SV_Str_view token) SV_ATTRIB_PURE</div><div class="ttdoc">Provides the status of the current tokenization for use in conditions such as loops.</div></div>
<div class="ttc" id="astr__view_8h_html_a4e6cb5dcc148fd82026f194299ebbe32"><div class="ttname"><a href="str__view_8h.html#a4e6cb5dcc148fd82026f194299ebbe32">SV_token_next</a></div><div class="ttdeci">SV_API SV_Str_view SV_token_next(SV_Str_view src, SV_Str_view token, SV_Str_view delim) SV_ATTRIB_PURE</div><div class="ttdoc">Advances to the next token in the remaining view separated by the delim.</div></div>
<div class="ttc" id="astr__view_8h_html_a62b250077ad955f6625508c890f2661f"><div class="ttname"><a href="str__view_8h.html#a62b250077ad955f6625508c890f2661f">SV_token_begin</a></div><div class="ttdeci">SV_API SV_Str_view SV_token_begin(SV_Str_view src, SV_Str_view delim) SV_ATTRIB_PURE</div><div class="ttdoc">Finds the first tokenized position in the string view given any length delim SV_Str_view.</div></div>
</div><!-- fragment --><p>However saving the <a class="el" href="structSV__Str__view.html" title="A read-only view of string data in C.">SV_Str_view</a> in a constant may be more convenient. </p>

</div>
</div>
<h2 class="groupheader">Enumeration Type Documentation</h2>
<a id="a648d7dfc8555055b2e5b742d0aa6fdf7" name="a648d7dfc8555055b2e5b742d0aa6fdf7"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a648d7dfc8555055b2e5b742d0aa6fdf7">&#9670;&#160;</a></span>SV_Order</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">enum <a class="el" href="str__view_8h.html#a648d7dfc8555055b2e5b742d0aa6fdf7">SV_Order</a></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Standard three way comparison type in C. </p>
<p>Orders the result of a comparison between left and right hand side elements, describing the order of the left hand side element compared to the right. </p>

</div>
</div>
<h2 class="groupheader">Function Documentation</h2>
<a id="ac5a6ed7644fef209bbb1348688798bf0" name="ac5a6ed7644fef209bbb1348688798bf0"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ac5a6ed7644fef209bbb1348688798bf0">&#9670;&#160;</a></span>SV_at()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="str__view_8h.html#ab632a39b679bbed9a2f8a8cbb6c04807">SV_API</a> char SV_at </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="structSV__Str__view.html">SV_Str_view</a>&#160;</td>
          <td class="paramname"><em>sv</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">size_t&#160;</td>
          <td class="paramname"><em>i</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Obtain a character at a position in the string view. </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramdir">[in]</td><td class="paramname">sv</td><td>the input string view. </td></tr>
    <tr><td class="paramdir">[in]</td><td class="paramname">i</td><td>the index within <code>[0, string view length - 1)</code> </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>the character in the string at position i with bounds checking. If i is greater than or equal to the size of <a class="el" href="structSV__Str__view.html" title="A read-only view of string data in C.">SV_Str_view</a> the null terminator character is returned. </dd></dl>

</div>
</div>
<a id="a035cd674c3935cc96aeac032d4db9485" name="a035cd674c3935cc96aeac032d4db9485"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a035cd674c3935cc96aeac032d4db9485">&#9670;&#160;</a></span>SV_back()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="str__view_8h.html#ab632a39b679bbed9a2f8a8cbb6c04807">SV_API</a> char SV_back </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="structSV__Str__view.html">SV_Str_view</a>&#160;</td>
          <td class="paramname"><em>sv</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Obtain the character at the last position of <a class="el" href="structSV__Str__view.html" title="A read-only view of string data in C.">SV_Str_view</a>. </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramdir">[in]</td><td class="paramname">sv</td><td>the input string view. </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>the last character in the string view. An empty <a class="el" href="structSV__Str__view.html" title="A read-only view of string data in C.">SV_Str_view</a> or NULL pointer is valid and will return '\0'. </dd></dl>

</div>
</div>
<a id="a46e8ee9b18ff6110dc8ec907442c8616" name="a46e8ee9b18ff6110dc8ec907442c8616"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a46e8ee9b18ff6110dc8ec907442c8616">&#9670;&#160;</a></span>SV_begin()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="str__view_8h.html#ab632a39b679bbed9a2f8a8cbb6c04807">SV_API</a> char const  * SV_begin </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="structSV__Str__view.html">SV_Str_view</a>&#160;</td>
          <td class="paramname"><em>sv</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Returns a read only pointer to the beginning of the string view, the first valid character in the view. </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramdir">[in]</td><td class="paramname">sv</td><td>the input string view. </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>if the view stores NULL, the placeholder <a class="el" href="str__view_8h.html#a7dcc45b3e74f7e8b64d825268ffacba7" title="A sentinel empty string. Safely dereference to view a null terminator. This may be returned from vari...">SV_null()</a> is returned. </dd></dl>

</div>
</div>
<a id="ab343394ad4ab6d05bef0793faf11c2df" name="ab343394ad4ab6d05bef0793faf11c2df"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ab343394ad4ab6d05bef0793faf11c2df">&#9670;&#160;</a></span>SV_bytes()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="str__view_8h.html#ab632a39b679bbed9a2f8a8cbb6c04807">SV_API</a> size_t SV_bytes </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="structSV__Str__view.html">SV_Str_view</a>&#160;</td>
          <td class="paramname"><em>sv</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">
<p>Returns the bytes of <a class="el" href="structSV__Str__view.html" title="A read-only view of string data in C.">SV_Str_view</a> including null terminator. </p><dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramdir">[in]</td><td class="paramname">sv</td><td>the string view to check. </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>the size in bytes of the view including the null terminator position character. </dd></dl>
<dl class="section note"><dt>Note</dt><dd>String views may not actually be null terminated but the position at <a class="el" href="structSV__Str__view.html" title="A read-only view of string data in C.">SV_Str_view</a>[<a class="el" href="structSV__Str__view.html#ad781fc69026844bdcc7519e672bc2740">SV_Str_view.len</a>] is interpreted as the null terminator and thus counts towards the byte count. </dd></dl>

</div>
</div>
<a id="a688dcdc0c6fe3901d71d114ad699c765" name="a688dcdc0c6fe3901d71d114ad699c765"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a688dcdc0c6fe3901d71d114ad699c765">&#9670;&#160;</a></span>SV_compare()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="str__view_8h.html#ab632a39b679bbed9a2f8a8cbb6c04807">SV_API</a> <a class="el" href="str__view_8h.html#a648d7dfc8555055b2e5b742d0aa6fdf7">SV_Order</a> SV_compare </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="structSV__Str__view.html">SV_Str_view</a>&#160;</td>
          <td class="paramname"><em>lhs</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="structSV__Str__view.html">SV_Str_view</a>&#160;</td>
          <td class="paramname"><em>rhs</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Returns the standard C threeway comparison between cmp(lhs, rhs) between two string views. </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramdir">[in]</td><td class="paramname">lhs</td><td>the string view left hand side. </td></tr>
    <tr><td class="paramdir">[in]</td><td class="paramname">rhs</td><td>the string view right hand side. </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>the order of the left hand side string view compared to the right hand side.</dd></dl>
<p>Comparison is bounded by the shorter <a class="el" href="structSV__Str__view.html" title="A read-only view of string data in C.">SV_Str_view</a> length. ERR is returned if bad input is provided such as a <a class="el" href="structSV__Str__view.html" title="A read-only view of string data in C.">SV_Str_view</a> with a NULL pointer field. </p>

</div>
</div>
<a id="abda3bd093b8f513f8d299b09e3894aa5" name="abda3bd093b8f513f8d299b09e3894aa5"></a>
<h2 class="memtitle"><span class="permalink"><a href="#abda3bd093b8f513f8d299b09e3894aa5">&#9670;&#160;</a></span>SV_contains()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="str__view_8h.html#ab632a39b679bbed9a2f8a8cbb6c04807">SV_API</a> bool SV_contains </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="structSV__Str__view.html">SV_Str_view</a>&#160;</td>
          <td class="paramname"><em>haystack</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="structSV__Str__view.html">SV_Str_view</a>&#160;</td>
          <td class="paramname"><em>needle</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Tests membership of needle in haystack. </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramdir">[in]</td><td class="paramname">haystack</td><td>the source string view to search. </td></tr>
    <tr><td class="paramdir">[in]</td><td class="paramname">needle</td><td>the substring to match within haystack. </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>true if the needle is found in the haystack, false otherwise. </dd></dl>

</div>
</div>
<a id="ac18f3e34b3533cb52347d9b18c05fb56" name="ac18f3e34b3533cb52347d9b18c05fb56"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ac18f3e34b3533cb52347d9b18c05fb56">&#9670;&#160;</a></span>SV_copy()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="str__view_8h.html#ab632a39b679bbed9a2f8a8cbb6c04807">SV_API</a> <a class="el" href="structSV__Str__view.html">SV_Str_view</a> SV_copy </td>
          <td>(</td>
          <td class="paramtype">size_t&#160;</td>
          <td class="paramname"><em>str_bytes</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">char const *&#160;</td>
          <td class="paramname"><em>src_str</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Copies the max of string bytes or input string length into a view, whichever ends first. </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramdir">[in]</td><td class="paramname">str_bytes</td><td>the number of bytes to scan, at most. </td></tr>
    <tr><td class="paramdir">[in]</td><td class="paramname">src_str</td><td>the null terminated string to scan. </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>a string view constructed from the minimum between the length of the input string and the provided byte count. </dd></dl>
<dl class="section warning"><dt>Warning</dt><dd>If no <code>\0</code> character is encountered, the character found at byte <code>str_bytes</code> of the input string is conceptually at the position of the null terminator of the view. </dd></dl>

</div>
</div>
<a id="a6951dd73c6c8828691ed6086ceb373d9" name="a6951dd73c6c8828691ed6086ceb373d9"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a6951dd73c6c8828691ed6086ceb373d9">&#9670;&#160;</a></span>SV_end()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="str__view_8h.html#ab632a39b679bbed9a2f8a8cbb6c04807">SV_API</a> char const  * SV_end </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="structSV__Str__view.html">SV_Str_view</a>&#160;</td>
          <td class="paramname"><em>sv</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Returns a read only pointer to the end of the string view. </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramdir">[in]</td><td class="paramname">sv</td><td>the view being iterated over. </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>the character pointer to the end of this iteration. This may or may not be a null terminated character depending on the view. If the view stores NULL, the placeholder <a class="el" href="str__view_8h.html#a7dcc45b3e74f7e8b64d825268ffacba7" title="A sentinel empty string. Safely dereference to view a null terminator. This may be returned from vari...">SV_null()</a> is returned. </dd></dl>

</div>
</div>
<a id="a4a51df59030495220376ee055dc6475b" name="a4a51df59030495220376ee055dc6475b"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a4a51df59030495220376ee055dc6475b">&#9670;&#160;</a></span>SV_ends_with()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="str__view_8h.html#ab632a39b679bbed9a2f8a8cbb6c04807">SV_API</a> bool SV_ends_with </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="structSV__Str__view.html">SV_Str_view</a>&#160;</td>
          <td class="paramname"><em>sv</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="structSV__Str__view.html">SV_Str_view</a>&#160;</td>
          <td class="paramname"><em>suffix</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Confirms the presence of a suffix within a string view. </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramdir">[in]</td><td class="paramname">sv</td><td>the string view to search. </td></tr>
    <tr><td class="paramdir">[in]</td><td class="paramname">suffix</td><td>the substring suffix to match with the input view. </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>true if a suffix shorter than or equal in length to the <a class="el" href="structSV__Str__view.html" title="A read-only view of string data in C.">SV_Str_view</a> is present, false otherwise. </dd></dl>

</div>
</div>
<a id="adf51d3f645a2f24fa6f6a2fbece51cdc" name="adf51d3f645a2f24fa6f6a2fbece51cdc"></a>
<h2 class="memtitle"><span class="permalink"><a href="#adf51d3f645a2f24fa6f6a2fbece51cdc">&#9670;&#160;</a></span>SV_extend()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="str__view_8h.html#ab632a39b679bbed9a2f8a8cbb6c04807">SV_API</a> <a class="el" href="structSV__Str__view.html">SV_Str_view</a> SV_extend </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="structSV__Str__view.html">SV_Str_view</a>&#160;</td>
          <td class="paramname"><em>sv</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Returns a <a class="el" href="structSV__Str__view.html" title="A read-only view of string data in C.">SV_Str_view</a> of the entirety of the underlying string, starting at the current view pointer position. </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramdir">[in]</td><td class="paramname">sv</td><td>the string view to extend. </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>a string view extended to include the rest of the characters before the null terminator of the underlying string.</dd></dl>
<p>This guarantees that the <a class="el" href="structSV__Str__view.html" title="A read-only view of string data in C.">SV_Str_view</a> returned ends at the null terminator of the underlying string as all strings used with SV_Str_views are assumed to be null terminated. It is undefined behavior to provide non null terminated strings to any <a class="el" href="structSV__Str__view.html" title="A read-only view of string data in C.">SV_Str_view</a> code. </p>

</div>
</div>
<a id="a73ef3f2b4b5fb182d447544677c7282c" name="a73ef3f2b4b5fb182d447544677c7282c"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a73ef3f2b4b5fb182d447544677c7282c">&#9670;&#160;</a></span>SV_fill()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="str__view_8h.html#ab632a39b679bbed9a2f8a8cbb6c04807">SV_API</a> size_t SV_fill </td>
          <td>(</td>
          <td class="paramtype">size_t&#160;</td>
          <td class="paramname"><em>dest_bytes</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">char *&#160;</td>
          <td class="paramname"><em>dest_buf</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="structSV__Str__view.html">SV_Str_view</a>&#160;</td>
          <td class="paramname"><em>src</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Fills the destination buffer with the minimum between destination size and source view size, null terminating the string. </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramdir">[in]</td><td class="paramname">dest_bytes</td><td>the bytes available in the destination. </td></tr>
    <tr><td class="paramdir">[in]</td><td class="paramname">dest_buf</td><td>the character buffer destination. </td></tr>
    <tr><td class="paramdir">[in]</td><td class="paramname">src</td><td>the string view to copy into the buffer. </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>the number of bytes successfully written, including the null terminator.</dd></dl>
<dl class="section warning"><dt>Warning</dt><dd>This may cut off src data if <code>destination bytes &lt; source length</code>. Returns how many bytes were written to the buffer. </dd></dl>

</div>
</div>
<a id="a93a55d034c1de8b45d51fcb22e879600" name="a93a55d034c1de8b45d51fcb22e879600"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a93a55d034c1de8b45d51fcb22e879600">&#9670;&#160;</a></span>SV_find()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="str__view_8h.html#ab632a39b679bbed9a2f8a8cbb6c04807">SV_API</a> size_t SV_find </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="structSV__Str__view.html">SV_Str_view</a>&#160;</td>
          <td class="paramname"><em>haystack</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">size_t&#160;</td>
          <td class="paramname"><em>pos</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="structSV__Str__view.html">SV_Str_view</a>&#160;</td>
          <td class="paramname"><em>needle</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Searches for needle in haystack starting from pos. </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramdir">[in]</td><td class="paramname">haystack</td><td>the string view to search. </td></tr>
    <tr><td class="paramdir">[in]</td><td class="paramname">pos</td><td>the position from which to start the search. </td></tr>
    <tr><td class="paramdir">[in]</td><td class="paramname">needle</td><td>the substring to match within haystack. </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>the index of the first character of the match. If the needle is larger than the haystack, or position is greater than haystack length, then haystack length (npos) is returned. </dd></dl>

</div>
</div>
<a id="aa05019727da818cc4bc585ed3d7ae32c" name="aa05019727da818cc4bc585ed3d7ae32c"></a>
<h2 class="memtitle"><span class="permalink"><a href="#aa05019727da818cc4bc585ed3d7ae32c">&#9670;&#160;</a></span>SV_find_first_not_of()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="str__view_8h.html#ab632a39b679bbed9a2f8a8cbb6c04807">SV_API</a> size_t SV_find_first_not_of </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="structSV__Str__view.html">SV_Str_view</a>&#160;</td>
          <td class="paramname"><em>haystack</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="structSV__Str__view.html">SV_Str_view</a>&#160;</td>
          <td class="paramname"><em>set</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">
<p>Finds the first position at which no characters in set can be found. </p><dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramdir">[in]</td><td class="paramname">haystack</td><td>the input view to search. </td></tr>
    <tr><td class="paramdir">[in]</td><td class="paramname">set</td><td>the set of characters banned in the search for of haystack. Each character in the input set is considered a valid match if encountered in haystack. </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>the position of the first occurrence of any character NOT in the input set provided. If only characters in the set are encountered haystack size is returned. An empty set (NULL) is valid, returning npos. An empty haystack returns 0. </dd></dl>

</div>
</div>
<a id="ad7419870318b8657fe00ce5fb7889b6a" name="ad7419870318b8657fe00ce5fb7889b6a"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ad7419870318b8657fe00ce5fb7889b6a">&#9670;&#160;</a></span>SV_find_first_of()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="str__view_8h.html#ab632a39b679bbed9a2f8a8cbb6c04807">SV_API</a> size_t SV_find_first_of </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="structSV__Str__view.html">SV_Str_view</a>&#160;</td>
          <td class="paramname"><em>haystack</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="structSV__Str__view.html">SV_Str_view</a>&#160;</td>
          <td class="paramname"><em>set</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">
<p>Finds the first position of an occurrence of any character in set. </p><dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramdir">[in]</td><td class="paramname">haystack</td><td>the input view to search. </td></tr>
    <tr><td class="paramdir">[in]</td><td class="paramname">set</td><td>the set of characters to search for in the haystack. Each character in the input set is considered a valid match if encountered in haystack. </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>the position of the first occurrence of any character in the input set provided. If no occurrence is found haystack size is returned. An empty set (NULL) is valid, returning npos. An empty haystack returns 0. </dd></dl>

</div>
</div>
<a id="aa5ea35766e4fdb45a0724f46f7d159fd" name="aa5ea35766e4fdb45a0724f46f7d159fd"></a>
<h2 class="memtitle"><span class="permalink"><a href="#aa5ea35766e4fdb45a0724f46f7d159fd">&#9670;&#160;</a></span>SV_find_last_not_of()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="str__view_8h.html#ab632a39b679bbed9a2f8a8cbb6c04807">SV_API</a> size_t SV_find_last_not_of </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="structSV__Str__view.html">SV_Str_view</a>&#160;</td>
          <td class="paramname"><em>haystack</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="structSV__Str__view.html">SV_Str_view</a>&#160;</td>
          <td class="paramname"><em>set</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">
<p>Finds the last position at which no characters in set can be found. </p><dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramdir">[in]</td><td class="paramname">haystack</td><td>the input view to search. </td></tr>
    <tr><td class="paramdir">[in]</td><td class="paramname">set</td><td>the set of characters banned in the search for of haystack. Each character in the input set is considered a valid match if encountered in haystack. </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>the position of the last occurrence of any character NOT in the input set provided. If only characters in the set are encountered haystack size is returned. An empty set (NULL) is valid, returning npos. An empty haystack returns 0. </dd></dl>

</div>
</div>
<a id="aeff05fad09dde73aeab519cbce425396" name="aeff05fad09dde73aeab519cbce425396"></a>
<h2 class="memtitle"><span class="permalink"><a href="#aeff05fad09dde73aeab519cbce425396">&#9670;&#160;</a></span>SV_find_last_of()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="str__view_8h.html#ab632a39b679bbed9a2f8a8cbb6c04807">SV_API</a> size_t SV_find_last_of </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="structSV__Str__view.html">SV_Str_view</a>&#160;</td>
          <td class="paramname"><em>haystack</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="structSV__Str__view.html">SV_Str_view</a>&#160;</td>
          <td class="paramname"><em>set</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">
<p>Finds the last position of an occurrence of any character in set. </p><dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramdir">[in]</td><td class="paramname">haystack</td><td>the input view to search. </td></tr>
    <tr><td class="paramdir">[in]</td><td class="paramname">set</td><td>the set of characters to search for in the haystack. Each character in the input set is considered a valid match if encountered in haystack. </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>the position of the last occurrence of any character in the input set provided. If no occurrence is found haystack size is returned. An empty set (NULL) is valid, returning npos. An empty haystack returns 0. </dd></dl>

</div>
</div>
<a id="a146a05bec7fd24999d74a2fa46223b9a" name="a146a05bec7fd24999d74a2fa46223b9a"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a146a05bec7fd24999d74a2fa46223b9a">&#9670;&#160;</a></span>SV_from_delimiter()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="str__view_8h.html#ab632a39b679bbed9a2f8a8cbb6c04807">SV_API</a> <a class="el" href="structSV__Str__view.html">SV_Str_view</a> SV_from_delimiter </td>
          <td>(</td>
          <td class="paramtype">char const *&#160;</td>
          <td class="paramname"><em>str</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">char const *&#160;</td>
          <td class="paramname"><em>delim</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Constructs and returns a string view from a null terminated string broken on the first occurrence of delimiter if found or null terminator if delim cannot be found. </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramdir">[in]</td><td class="paramname">str</td><td>the null terminated input string. </td></tr>
    <tr><td class="paramdir">[in]</td><td class="paramname">delim</td><td>the null terminated delimiter on which to break. </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>the constructed string view broken on the first occurrence of the delimiter or the entire string if no delimiter is found.</dd></dl>
<p>This constructor will also skip the delimiter if that delimiter starts the string. This is similar to the tokenizing function in the iteration section. </p>

</div>
</div>
<a id="acfe5d77c0a37dfeafc737e62abd8aa19" name="acfe5d77c0a37dfeafc737e62abd8aa19"></a>
<h2 class="memtitle"><span class="permalink"><a href="#acfe5d77c0a37dfeafc737e62abd8aa19">&#9670;&#160;</a></span>SV_from_terminated()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="str__view_8h.html#ab632a39b679bbed9a2f8a8cbb6c04807">SV_API</a> <a class="el" href="structSV__Str__view.html">SV_Str_view</a> SV_from_terminated </td>
          <td>(</td>
          <td class="paramtype">char const *&#160;</td>
          <td class="paramname"><em>str</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Constructs and returns a string view from a null terminated string. </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramdir">[in]</td><td class="paramname">str</td><td>a pointer to the null terminated string. </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>a constructed string view in linear time at runtime. </dd></dl>
<dl class="section warning"><dt>Warning</dt><dd>The provided string must be null terminated. It is expected that all strings provided to string views are null terminated. </dd></dl>

</div>
</div>
<a id="a2923ce2c520b5963cd37250b66e9d196" name="a2923ce2c520b5963cd37250b66e9d196"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a2923ce2c520b5963cd37250b66e9d196">&#9670;&#160;</a></span>SV_from_view()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="str__view_8h.html#ab632a39b679bbed9a2f8a8cbb6c04807">SV_API</a> <a class="el" href="structSV__Str__view.html">SV_Str_view</a> SV_from_view </td>
          <td>(</td>
          <td class="paramtype">size_t&#160;</td>
          <td class="paramname"><em>n</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">char const *&#160;</td>
          <td class="paramname"><em>str</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Constructs and returns a string view from a sequence of valid n bytes or string length, whichever comes first. </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramdir">[in]</td><td class="paramname">n</td><td>the number of bytes to scan, at most. </td></tr>
    <tr><td class="paramdir">[in]</td><td class="paramname">str</td><td>the null terminated string to scan. </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>a string view constructed from the minimum between the length of the input string and the provided byte count. </dd></dl>
<dl class="section warning"><dt>Warning</dt><dd>If no <code>\0</code> character is encountered, the character found at byte <code>n</code> of the input string is conceptually at the position of the null terminator of the view. </dd></dl>

</div>
</div>
<a id="aedcbc80e6658730cc9cf17f9cddeb351" name="aedcbc80e6658730cc9cf17f9cddeb351"></a>
<h2 class="memtitle"><span class="permalink"><a href="#aedcbc80e6658730cc9cf17f9cddeb351">&#9670;&#160;</a></span>SV_front()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="str__view_8h.html#ab632a39b679bbed9a2f8a8cbb6c04807">SV_API</a> char SV_front </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="structSV__Str__view.html">SV_Str_view</a>&#160;</td>
          <td class="paramname"><em>sv</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Obtain the character at the first position of <a class="el" href="structSV__Str__view.html" title="A read-only view of string data in C.">SV_Str_view</a>. </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramdir">[in]</td><td class="paramname">sv</td><td>the input string view. </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>the first character in the string view. An empty <a class="el" href="structSV__Str__view.html" title="A read-only view of string data in C.">SV_Str_view</a> or NULL pointer is valid and will return '\0'. </dd></dl>

</div>
</div>
<a id="a9bbd790f94c692b9414e2f66208aaf38" name="a9bbd790f94c692b9414e2f66208aaf38"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a9bbd790f94c692b9414e2f66208aaf38">&#9670;&#160;</a></span>SV_is_empty()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="str__view_8h.html#ab632a39b679bbed9a2f8a8cbb6c04807">SV_API</a> bool SV_is_empty </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="structSV__Str__view.html">SV_Str_view</a>&#160;</td>
          <td class="paramname"><em>sv</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Returns true if the provided <a class="el" href="structSV__Str__view.html" title="A read-only view of string data in C.">SV_Str_view</a> is empty, false otherwise. </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramdir">[in]</td><td class="paramname">sv</td><td>the string view to check. </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>true if empty otherwise false.</dd></dl>
<p>This is a useful function to check for <a class="el" href="structSV__Str__view.html" title="A read-only view of string data in C.">SV_Str_view</a> searches that yield an empty view at the end of a <a class="el" href="structSV__Str__view.html" title="A read-only view of string data in C.">SV_Str_view</a> when an element cannot be found. </p>

</div>
</div>
<a id="a4212c23637ecd0ca93539cec3967d080" name="a4212c23637ecd0ca93539cec3967d080"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a4212c23637ecd0ca93539cec3967d080">&#9670;&#160;</a></span>SV_len()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="str__view_8h.html#ab632a39b679bbed9a2f8a8cbb6c04807">SV_API</a> size_t SV_len </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="structSV__Str__view.html">SV_Str_view</a>&#160;</td>
          <td class="paramname"><em>sv</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Returns the length of the <a class="el" href="structSV__Str__view.html" title="A read-only view of string data in C.">SV_Str_view</a> in O(1) time. </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramdir">[in]</td><td class="paramname">sv</td><td>the string view to check. </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>the length of the string view, not including the null terminator byte.</dd></dl>
<p>The position at <a class="el" href="structSV__Str__view.html" title="A read-only view of string data in C.">SV_Str_view</a> size is interpreted as the null terminator and not counted toward length of a <a class="el" href="structSV__Str__view.html" title="A read-only view of string data in C.">SV_Str_view</a>. </p>

</div>
</div>
<a id="ac5c032d8aef68920426ed01818a9ebf0" name="ac5c032d8aef68920426ed01818a9ebf0"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ac5c032d8aef68920426ed01818a9ebf0">&#9670;&#160;</a></span>SV_match()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="str__view_8h.html#ab632a39b679bbed9a2f8a8cbb6c04807">SV_API</a> <a class="el" href="structSV__Str__view.html">SV_Str_view</a> SV_match </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="structSV__Str__view.html">SV_Str_view</a>&#160;</td>
          <td class="paramname"><em>haystack</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="structSV__Str__view.html">SV_Str_view</a>&#160;</td>
          <td class="paramname"><em>needle</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Search for a substring within a source string view. </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramdir">[in]</td><td class="paramname">haystack</td><td>the source string view to search. </td></tr>
    <tr><td class="paramdir">[in]</td><td class="paramname">needle</td><td>the substring to match within haystack. </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>a view of the needle found in haystack at the first found position. If the needle cannot be found the empty view at the haystack length position is returned. This may or may not be null terminated at that position. If needle is greater than haystack length an empty view at the end of haystack is returned. If haystack is NULL, SV_null is returned. </dd></dl>

</div>
</div>
<a id="abb04b423a7122b27cd6ea12dd78a0134" name="abb04b423a7122b27cd6ea12dd78a0134"></a>
<h2 class="memtitle"><span class="permalink"><a href="#abb04b423a7122b27cd6ea12dd78a0134">&#9670;&#160;</a></span>SV_min_len()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="str__view_8h.html#ab632a39b679bbed9a2f8a8cbb6c04807">SV_API</a> size_t SV_min_len </td>
          <td>(</td>
          <td class="paramtype">char const *&#160;</td>
          <td class="paramname"><em>str</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">size_t&#160;</td>
          <td class="paramname"><em>n</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Returns the minimum between the string size vs n bytes. </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramdir">[in]</td><td class="paramname">str</td><td>the null terminated input string. </td></tr>
    <tr><td class="paramdir">[in]</td><td class="paramname">n</td><td>the limiting byte count to compare. </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>the minimum between the length of the string and n. </dd></dl>

</div>
</div>
<a id="a8f9fa408933690832b2ae4df3643167a" name="a8f9fa408933690832b2ae4df3643167a"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a8f9fa408933690832b2ae4df3643167a">&#9670;&#160;</a></span>SV_next()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="str__view_8h.html#ab632a39b679bbed9a2f8a8cbb6c04807">SV_API</a> char const  * SV_next </td>
          <td>(</td>
          <td class="paramtype">char const *&#160;</td>
          <td class="paramname"><em>c</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Advances the null terminated string pointer from its previous position. If NULL is provided <a class="el" href="str__view_8h.html#a7dcc45b3e74f7e8b64d825268ffacba7" title="A sentinel empty string. Safely dereference to view a null terminator. This may be returned from vari...">SV_null()</a> is returned. </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramdir">[in]</td><td class="paramname">c</td><td>the pointer to a null terminated string iterator. </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>the next character in the string or the end iterator if no characters remain. </dd></dl>

</div>
</div>
<a id="ada02c23f45597bf76446a8ca3ce22983" name="ada02c23f45597bf76446a8ca3ce22983"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ada02c23f45597bf76446a8ca3ce22983">&#9670;&#160;</a></span>SV_npos()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="str__view_8h.html#ab632a39b679bbed9a2f8a8cbb6c04807">SV_API</a> size_t SV_npos </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="structSV__Str__view.html">SV_Str_view</a>&#160;</td>
          <td class="paramname"><em>sv</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>The end of a <a class="el" href="structSV__Str__view.html" title="A read-only view of string data in C.">SV_Str_view</a> guaranteed to be greater than or equal to size. </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramdir">[in]</td><td class="paramname">sv</td><td>the string view. </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>the end position of the string as an index.</dd></dl>
<p>This value may be used for the idiomatic check for most string searching function return values when something is not found. If a size is returned from a searching function it is possible to check it against this value. </p>

</div>
</div>
<a id="a7dcc45b3e74f7e8b64d825268ffacba7" name="a7dcc45b3e74f7e8b64d825268ffacba7"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a7dcc45b3e74f7e8b64d825268ffacba7">&#9670;&#160;</a></span>SV_null()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="str__view_8h.html#ab632a39b679bbed9a2f8a8cbb6c04807">SV_API</a> char const  * SV_null </td>
          <td>(</td>
          <td class="paramtype">void&#160;</td>
          <td class="paramname"></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>A sentinel empty string. Safely dereference to view a null terminator. This may be returned from various functions when bad input is given such as NULL pointers as the underlying <a class="el" href="structSV__Str__view.html" title="A read-only view of string data in C.">SV_Str_view</a> string pointer. </p>
<dl class="section return"><dt>Returns</dt><dd>a read only character pointer that points to a null terminator and can be safely dereferenced. </dd></dl>

</div>
</div>
<a id="a273d93cb03aafaf8722e850b98fd2e0a" name="a273d93cb03aafaf8722e850b98fd2e0a"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a273d93cb03aafaf8722e850b98fd2e0a">&#9670;&#160;</a></span>SV_pointer()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="str__view_8h.html#ab632a39b679bbed9a2f8a8cbb6c04807">SV_API</a> char const  * SV_pointer </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="structSV__Str__view.html">SV_Str_view</a>&#160;</td>
          <td class="paramname"><em>sv</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">size_t&#160;</td>
          <td class="paramname"><em>i</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Returns the character pointer at the minimum between the indicated position and the end of the string view. </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramdir">[in]</td><td class="paramname">sv</td><td>the string view input. </td></tr>
    <tr><td class="paramdir">[in]</td><td class="paramname">i</td><td>the index within range of <code>[0, string view length - 1)</code>. </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>a pointer to the character at the designated index. If NULL is stored by the <a class="el" href="structSV__Str__view.html" title="A read-only view of string data in C.">SV_Str_view</a> then <a class="el" href="str__view_8h.html#a7dcc45b3e74f7e8b64d825268ffacba7" title="A sentinel empty string. Safely dereference to view a null terminator. This may be returned from vari...">SV_null()</a> is returned. </dd></dl>

</div>
</div>
<a id="a55d65ba65e53a6b4cebac2bc8f20d260" name="a55d65ba65e53a6b4cebac2bc8f20d260"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a55d65ba65e53a6b4cebac2bc8f20d260">&#9670;&#160;</a></span>SV_remove_prefix()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="str__view_8h.html#ab632a39b679bbed9a2f8a8cbb6c04807">SV_API</a> <a class="el" href="structSV__Str__view.html">SV_Str_view</a> SV_remove_prefix </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="structSV__Str__view.html">SV_Str_view</a>&#160;</td>
          <td class="paramname"><em>sv</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">size_t&#160;</td>
          <td class="paramname"><em>n</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">
<p>Removes the minimum between <a class="el" href="structSV__Str__view.html" title="A read-only view of string data in C.">SV_Str_view</a> length and n from the start of the <a class="el" href="structSV__Str__view.html" title="A read-only view of string data in C.">SV_Str_view</a>. </p><dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramdir">[in]</td><td class="paramname">sv</td><td>the input string view. </td></tr>
    <tr><td class="paramdir">[in]</td><td class="paramname">n</td><td>the bytes to remove from the start of the input view. </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>the new view with the requested bytes removed from the start.</dd></dl>
<p>It is safe to provide n larger than <a class="el" href="structSV__Str__view.html" title="A read-only view of string data in C.">SV_Str_view</a> size as that will result in a size 0 view to the end of the current view which may or may not be the null terminator. </p>

</div>
</div>
<a id="aaed44c202a2e11978aca3d06877a00db" name="aaed44c202a2e11978aca3d06877a00db"></a>
<h2 class="memtitle"><span class="permalink"><a href="#aaed44c202a2e11978aca3d06877a00db">&#9670;&#160;</a></span>SV_remove_suffix()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="str__view_8h.html#ab632a39b679bbed9a2f8a8cbb6c04807">SV_API</a> <a class="el" href="structSV__Str__view.html">SV_Str_view</a> SV_remove_suffix </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="structSV__Str__view.html">SV_Str_view</a>&#160;</td>
          <td class="paramname"><em>sv</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">size_t&#160;</td>
          <td class="paramname"><em>n</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">
<p>Removes the minimum between <a class="el" href="structSV__Str__view.html" title="A read-only view of string data in C.">SV_Str_view</a> length and n from the end of the <a class="el" href="structSV__Str__view.html" title="A read-only view of string data in C.">SV_Str_view</a>. </p><dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramdir">[in]</td><td class="paramname">sv</td><td>the input string view. </td></tr>
    <tr><td class="paramdir">[in]</td><td class="paramname">n</td><td>the bytes to remove from the end of the input view. </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>the new view with the requested bytes removed from the end.</dd></dl>
<p>It is safe to provide n larger than <a class="el" href="structSV__Str__view.html" title="A read-only view of string data in C.">SV_Str_view</a> size as that will result in a size 0 view to the end of the current view which may or may not be the null terminator. </p>

</div>
</div>
<a id="a138480842acd552567d9ad95c83cb71c" name="a138480842acd552567d9ad95c83cb71c"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a138480842acd552567d9ad95c83cb71c">&#9670;&#160;</a></span>SV_reverse_begin()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="str__view_8h.html#ab632a39b679bbed9a2f8a8cbb6c04807">SV_API</a> char const  * SV_reverse_begin </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="structSV__Str__view.html">SV_Str_view</a>&#160;</td>
          <td class="paramname"><em>sv</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Returns the reverse iterator beginning, the last character of the current view. </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramdir">[in]</td><td class="paramname">sv</td><td>the input string view. </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>if the view is null <a class="el" href="str__view_8h.html#a7dcc45b3e74f7e8b64d825268ffacba7" title="A sentinel empty string. Safely dereference to view a null terminator. This may be returned from vari...">SV_null()</a> is returned. If the view is sized zero with a valid pointer that pointer in the view is returned. </dd></dl>

</div>
</div>
<a id="a5cbbc03e7e0fbc110b66e5b5458d3e47" name="a5cbbc03e7e0fbc110b66e5b5458d3e47"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a5cbbc03e7e0fbc110b66e5b5458d3e47">&#9670;&#160;</a></span>SV_reverse_end()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="str__view_8h.html#ab632a39b679bbed9a2f8a8cbb6c04807">SV_API</a> char const  * SV_reverse_end </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="structSV__Str__view.html">SV_Str_view</a>&#160;</td>
          <td class="paramname"><em>sv</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>The ending position of a reverse iteration. </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramdir">[in]</td><td class="paramname">sv</td><td>the view being iterated over in reverse. </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>the character position at the reverse end of this iteration. </dd></dl>
<dl class="section warning"><dt>Warning</dt><dd>It is undefined behavior to access or use rend. It is undefined behavior to pass in any <a class="el" href="structSV__Str__view.html" title="A read-only view of string data in C.">SV_Str_view</a> not being iterated through as started with reverse_begin. </dd></dl>

</div>
</div>
<a id="a3b1ee28c15cef81bfe06294ca2a90421" name="a3b1ee28c15cef81bfe06294ca2a90421"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a3b1ee28c15cef81bfe06294ca2a90421">&#9670;&#160;</a></span>SV_reverse_find()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="str__view_8h.html#ab632a39b679bbed9a2f8a8cbb6c04807">SV_API</a> size_t SV_reverse_find </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="structSV__Str__view.html">SV_Str_view</a>&#160;</td>
          <td class="paramname"><em>haystack</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">size_t&#160;</td>
          <td class="paramname"><em>pos</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="structSV__Str__view.html">SV_Str_view</a>&#160;</td>
          <td class="paramname"><em>needle</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Searches for the last occurrence of needle in haystack starting from pos from right to left. </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramdir">[in]</td><td class="paramname">haystack</td><td>the string view to search. </td></tr>
    <tr><td class="paramdir">[in]</td><td class="paramname">pos</td><td>the position from which to start the search. </td></tr>
    <tr><td class="paramdir">[in]</td><td class="paramname">needle</td><td>the substring to match within haystack. </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>if found the starting position of the string is returned, the same as find. If not found haystack size is returned. The only difference from find is the search direction. If needle is larger than haystack, haystack length is returned.</dd></dl>
<p>If the position is larger than the haystack, the entire haystack is searched. </p>

</div>
</div>
<a id="a77a42a2acef5e7a57516d0eb78cc338e" name="a77a42a2acef5e7a57516d0eb78cc338e"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a77a42a2acef5e7a57516d0eb78cc338e">&#9670;&#160;</a></span>SV_reverse_match()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="str__view_8h.html#ab632a39b679bbed9a2f8a8cbb6c04807">SV_API</a> <a class="el" href="structSV__Str__view.html">SV_Str_view</a> SV_reverse_match </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="structSV__Str__view.html">SV_Str_view</a>&#160;</td>
          <td class="paramname"><em>haystack</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="structSV__Str__view.html">SV_Str_view</a>&#160;</td>
          <td class="paramname"><em>needle</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Search for a substring within a source string in reverse. </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramdir">[in]</td><td class="paramname">haystack</td><td>the source string view to reverse search. </td></tr>
    <tr><td class="paramdir">[in]</td><td class="paramname">needle</td><td>the substring to match within haystack. </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>a view of the needle found in haystack at the last found position. If the needle cannot be found the empty view at the haystack length position is returned. This may or may not be null terminated at that position. If needle is greater than haystack length an empty view at haystack size is returned. If haystack is NULL, SV_null is returned (modeled after strstr). </dd></dl>

</div>
</div>
<a id="a36a2d227f439ab73152a172cca2150aa" name="a36a2d227f439ab73152a172cca2150aa"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a36a2d227f439ab73152a172cca2150aa">&#9670;&#160;</a></span>SV_reverse_next()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="str__view_8h.html#ab632a39b679bbed9a2f8a8cbb6c04807">SV_API</a> char const  * SV_reverse_next </td>
          <td>(</td>
          <td class="paramtype">char const *&#160;</td>
          <td class="paramname"><em>c</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Advances the iterator to the next character in the <a class="el" href="structSV__Str__view.html" title="A read-only view of string data in C.">SV_Str_view</a> being iterated through in reverse. </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramdir">[in]</td><td class="paramname">c</td><td>the pointer to the null terminated string iterator. </td></tr>
  </table>
  </dd>
</dl>
<dl class="section warning"><dt>Warning</dt><dd>It is undefined behavior to change the <a class="el" href="structSV__Str__view.html" title="A read-only view of string data in C.">SV_Str_view</a> one is iterating through during iteration. If the char pointer is null, <a class="el" href="str__view_8h.html#a7dcc45b3e74f7e8b64d825268ffacba7" title="A sentinel empty string. Safely dereference to view a null terminator. This may be returned from vari...">SV_null()</a> is returned. </dd></dl>

</div>
</div>
<a id="ae1ed256cc213d1c5ce599a80095f13e8" name="ae1ed256cc213d1c5ce599a80095f13e8"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ae1ed256cc213d1c5ce599a80095f13e8">&#9670;&#160;</a></span>SV_starts_with()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="str__view_8h.html#ab632a39b679bbed9a2f8a8cbb6c04807">SV_API</a> bool SV_starts_with </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="structSV__Str__view.html">SV_Str_view</a>&#160;</td>
          <td class="paramname"><em>sv</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="structSV__Str__view.html">SV_Str_view</a>&#160;</td>
          <td class="paramname"><em>prefix</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Confirms the presence of a prefix within a string view. </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramdir">[in]</td><td class="paramname">sv</td><td>the string view to search. </td></tr>
    <tr><td class="paramdir">[in]</td><td class="paramname">prefix</td><td>the substring prefix to match with the input view. </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>true if a prefix shorter than or equal in length to the <a class="el" href="structSV__Str__view.html" title="A read-only view of string data in C.">SV_Str_view</a> is present, false otherwise. </dd></dl>

</div>
</div>
<a id="a62b1315242b9acfbfdd38dcbefe0e7f3" name="a62b1315242b9acfbfdd38dcbefe0e7f3"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a62b1315242b9acfbfdd38dcbefe0e7f3">&#9670;&#160;</a></span>SV_str_bytes()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="str__view_8h.html#ab632a39b679bbed9a2f8a8cbb6c04807">SV_API</a> size_t SV_str_bytes </td>
          <td>(</td>
          <td class="paramtype">char const *&#160;</td>
          <td class="paramname"><em>str</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Returns the bytes of the string pointer to, null terminator included. </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramdir">[in]</td><td class="paramname">str</td><td>the null terminated input string. </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>the size in bytes of str, including the null terminator. </dd></dl>

</div>
</div>
<a id="a6ffc135012b68a396f786638f5ac6278" name="a6ffc135012b68a396f786638f5ac6278"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a6ffc135012b68a396f786638f5ac6278">&#9670;&#160;</a></span>SV_substr()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="str__view_8h.html#ab632a39b679bbed9a2f8a8cbb6c04807">SV_API</a> <a class="el" href="structSV__Str__view.html">SV_Str_view</a> SV_substr </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="structSV__Str__view.html">SV_Str_view</a>&#160;</td>
          <td class="paramname"><em>sv</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">size_t&#160;</td>
          <td class="paramname"><em>pos</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">size_t&#160;</td>
          <td class="paramname"><em>count</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Creates the substring from position pos for count length. The count is the minimum value between count and <code>(length - pos)</code>. </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramdir">[in]</td><td class="paramname">sv</td><td>the string view. </td></tr>
    <tr><td class="paramdir">[in]</td><td class="paramname">pos</td><td>the position from which to start the substring. </td></tr>
    <tr><td class="paramdir">[in]</td><td class="paramname">count</td><td>the new string length of the substring. </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>a newly constructed string view substring. If an invalid position is given greater than <a class="el" href="structSV__Str__view.html" title="A read-only view of string data in C.">SV_Str_view</a> length an empty view is returned positioned at the end of <a class="el" href="structSV__Str__view.html" title="A read-only view of string data in C.">SV_Str_view</a>. </dd></dl>
<dl class="section warning"><dt>Warning</dt><dd>The end position may or may not hold the null terminator. </dd></dl>

</div>
</div>
<a id="af7d6a7d0e99847c09f13183a84ced42e" name="af7d6a7d0e99847c09f13183a84ced42e"></a>
<h2 class="memtitle"><span class="permalink"><a href="#af7d6a7d0e99847c09f13183a84ced42e">&#9670;&#160;</a></span>SV_terminated_compare()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="str__view_8h.html#ab632a39b679bbed9a2f8a8cbb6c04807">SV_API</a> <a class="el" href="str__view_8h.html#a648d7dfc8555055b2e5b742d0aa6fdf7">SV_Order</a> SV_terminated_compare </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="structSV__Str__view.html">SV_Str_view</a>&#160;</td>
          <td class="paramname"><em>lhs</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">char const *&#160;</td>
          <td class="paramname"><em>rhs</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Returns the standard C threeway comparison between cmp(lhs, rhs) between a <a class="el" href="structSV__Str__view.html" title="A read-only view of string data in C.">SV_Str_view</a> and a C string. </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramdir">[in]</td><td class="paramname">lhs</td><td>the string view that serves as the left hand side of the order. </td></tr>
    <tr><td class="paramdir">[in]</td><td class="paramname">rhs</td><td>the null terminated string to compare against. </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>the order of the left hand side compared to the right hand side: <code>SV_ORDER_LESSER</code>, <code>SV_ORDER_EQUAL</code>, or <code>SV_ORDER_GREATER</code>.</dd></dl>
<p>Comparison is bounded by the shorter <a class="el" href="structSV__Str__view.html" title="A read-only view of string data in C.">SV_Str_view</a> length. An error value is returned if bad input is provided such as a <a class="el" href="structSV__Str__view.html" title="A read-only view of string data in C.">SV_Str_view</a> with a NULL pointer field. </p>

</div>
</div>
<a id="a62b250077ad955f6625508c890f2661f" name="a62b250077ad955f6625508c890f2661f"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a62b250077ad955f6625508c890f2661f">&#9670;&#160;</a></span>SV_token_begin()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="str__view_8h.html#ab632a39b679bbed9a2f8a8cbb6c04807">SV_API</a> <a class="el" href="structSV__Str__view.html">SV_Str_view</a> SV_token_begin </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="structSV__Str__view.html">SV_Str_view</a>&#160;</td>
          <td class="paramname"><em>src</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="structSV__Str__view.html">SV_Str_view</a>&#160;</td>
          <td class="paramname"><em>delim</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Finds the first tokenized position in the string view given any length delim <a class="el" href="structSV__Str__view.html" title="A read-only view of string data in C.">SV_Str_view</a>. </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramdir">[in]</td><td class="paramname">src</td><td>the source string view to tokenize. </td></tr>
    <tr><td class="paramdir">[in]</td><td class="paramname">delim</td><td>the delimiter that separates tokens. </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>the first token encountered in the source view or the entire view if no token was found. Skips leading delimiters in construction. If the <a class="el" href="structSV__Str__view.html" title="A read-only view of string data in C.">SV_Str_view</a> to be searched stores NULL than the <a class="el" href="str__view_8h.html#a7dcc45b3e74f7e8b64d825268ffacba7" title="A sentinel empty string. Safely dereference to view a null terminator. This may be returned from vari...">SV_null()</a> is returned. If delim stores NULL, that is interpreted as a search for the null terminating character or empty string and the size zero substring at the final position in the <a class="el" href="structSV__Str__view.html" title="A read-only view of string data in C.">SV_Str_view</a> is returned wich may or may not be the null termiator. If no delim is found the entire <a class="el" href="structSV__Str__view.html" title="A read-only view of string data in C.">SV_Str_view</a> is returned. </dd></dl>

</div>
</div>
<a id="a405f4d6a75078d52dd7ebb38877796e0" name="a405f4d6a75078d52dd7ebb38877796e0"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a405f4d6a75078d52dd7ebb38877796e0">&#9670;&#160;</a></span>SV_token_end()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="str__view_8h.html#ab632a39b679bbed9a2f8a8cbb6c04807">SV_API</a> bool SV_token_end </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="structSV__Str__view.html">SV_Str_view</a>&#160;</td>
          <td class="paramname"><em>src</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="structSV__Str__view.html">SV_Str_view</a>&#160;</td>
          <td class="paramname"><em>token</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Provides the status of the current tokenization for use in conditions such as loops. </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramdir">[in]</td><td class="paramname">src</td><td>the source view being tokenized. </td></tr>
    <tr><td class="paramdir">[in]</td><td class="paramname">token</td><td>the current token obtained from tokenization. </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>true if no further tokens are found and position is at the end position, meaning a call to <a class="el" href="str__view_8h.html#a62b250077ad955f6625508c890f2661f" title="Finds the first tokenized position in the string view given any length delim SV_Str_view.">SV_token_begin()</a> or <a class="el" href="str__view_8h.html#a4e6cb5dcc148fd82026f194299ebbe32" title="Advances to the next token in the remaining view separated by the delim.">SV_token_next()</a> has yielded a size 0 <a class="el" href="structSV__Str__view.html" title="A read-only view of string data in C.">SV_Str_view</a> that points at the end of the src <a class="el" href="structSV__Str__view.html" title="A read-only view of string data in C.">SV_Str_view</a>, which may or may not be null terminated. </dd></dl>

</div>
</div>
<a id="a4e6cb5dcc148fd82026f194299ebbe32" name="a4e6cb5dcc148fd82026f194299ebbe32"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a4e6cb5dcc148fd82026f194299ebbe32">&#9670;&#160;</a></span>SV_token_next()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="str__view_8h.html#ab632a39b679bbed9a2f8a8cbb6c04807">SV_API</a> <a class="el" href="structSV__Str__view.html">SV_Str_view</a> SV_token_next </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="structSV__Str__view.html">SV_Str_view</a>&#160;</td>
          <td class="paramname"><em>src</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="structSV__Str__view.html">SV_Str_view</a>&#160;</td>
          <td class="paramname"><em>token</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="structSV__Str__view.html">SV_Str_view</a>&#160;</td>
          <td class="paramname"><em>delim</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Advances to the next token in the remaining view separated by the delim. </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramdir">[in]</td><td class="paramname">src</td><td>the source string view being tokenized. </td></tr>
    <tr><td class="paramdir">[in]</td><td class="paramname">token</td><td>the current token obtained from tokenizing. </td></tr>
    <tr><td class="paramdir">[in]</td><td class="paramname">delim</td><td>the delimeter that separates tokens. </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>the string view of the next available token. Repeating delimiter patterns will be skipped until the next token or end of string is found. If <a class="el" href="structSV__Str__view.html" title="A read-only view of string data in C.">SV_Str_view</a> stores NULL the <a class="el" href="str__view_8h.html#a7dcc45b3e74f7e8b64d825268ffacba7" title="A sentinel empty string. Safely dereference to view a null terminator. This may be returned from vari...">SV_null()</a> placeholder is returned. If delim stores NULL the end position of the <a class="el" href="structSV__Str__view.html" title="A read-only view of string data in C.">SV_Str_view</a> is returned which may or may not be the null terminator. The token is bounded by the length of the view between two delimiters or the length from a delimiter to the end of src, whichever comes first. </dd></dl>

</div>
</div>
<a id="ac68c938032a96116e93902e9e9d749da" name="ac68c938032a96116e93902e9e9d749da"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ac68c938032a96116e93902e9e9d749da">&#9670;&#160;</a></span>SV_token_reverse_begin()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="str__view_8h.html#ab632a39b679bbed9a2f8a8cbb6c04807">SV_API</a> <a class="el" href="structSV__Str__view.html">SV_Str_view</a> SV_token_reverse_begin </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="structSV__Str__view.html">SV_Str_view</a>&#160;</td>
          <td class="paramname"><em>src</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="structSV__Str__view.html">SV_Str_view</a>&#160;</td>
          <td class="paramname"><em>delim</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">
<p>Obtains the last token in a string in preparation for reverse tokenized iteration. </p><dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramdir">[in]</td><td class="paramname">src</td><td>the source view to tokenize in reverse. </td></tr>
    <tr><td class="paramdir">[in]</td><td class="paramname">delim</td><td>the delimiter that separates tokens. </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>the last token in the source view or the entire view if no token was found. Any delimiters that end the string are skipped, as in the forward version. If src is NULL SV_null is returned. If delim is null the entire src view is returned. </dd></dl>
<dl class="section note"><dt>Note</dt><dd>Though the <a class="el" href="structSV__Str__view.html" title="A read-only view of string data in C.">SV_Str_view</a> is tokenized in reverse, the token view returned will start at the first character and be the length of the token found. </dd></dl>

</div>
</div>
<a id="a75dcc72fda448d3ca49789a8efbe95f9" name="a75dcc72fda448d3ca49789a8efbe95f9"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a75dcc72fda448d3ca49789a8efbe95f9">&#9670;&#160;</a></span>SV_token_reverse_end()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="str__view_8h.html#ab632a39b679bbed9a2f8a8cbb6c04807">SV_API</a> bool SV_token_reverse_end </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="structSV__Str__view.html">SV_Str_view</a>&#160;</td>
          <td class="paramname"><em>src</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="structSV__Str__view.html">SV_Str_view</a>&#160;</td>
          <td class="paramname"><em>token</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Provides the status of the current tokenization for use in conditions such as loops. </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramdir">[in]</td><td class="paramname">src</td><td>the source view being tokenized. </td></tr>
    <tr><td class="paramdir">[in]</td><td class="paramname">token</td><td>the current token obtained from tokenization. </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>true if no further tokens are found and position is at the start position, meaning a call to <a class="el" href="str__view_8h.html#ac68c938032a96116e93902e9e9d749da">SV_token_reverse_begin()</a> or <a class="el" href="str__view_8h.html#a655161c9c6e475c7da280d622c63740a" title="Advances the token in src to the next token between two delimiters provided by delim.">SV_token_reverse_next()</a> has yielded a size 0 <a class="el" href="structSV__Str__view.html" title="A read-only view of string data in C.">SV_Str_view</a> that points at the start of the src <a class="el" href="structSV__Str__view.html" title="A read-only view of string data in C.">SV_Str_view</a>. </dd></dl>

</div>
</div>
<a id="a655161c9c6e475c7da280d622c63740a" name="a655161c9c6e475c7da280d622c63740a"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a655161c9c6e475c7da280d622c63740a">&#9670;&#160;</a></span>SV_token_reverse_next()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="str__view_8h.html#ab632a39b679bbed9a2f8a8cbb6c04807">SV_API</a> <a class="el" href="structSV__Str__view.html">SV_Str_view</a> SV_token_reverse_next </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="structSV__Str__view.html">SV_Str_view</a>&#160;</td>
          <td class="paramname"><em>src</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="structSV__Str__view.html">SV_Str_view</a>&#160;</td>
          <td class="paramname"><em>token</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="structSV__Str__view.html">SV_Str_view</a>&#160;</td>
          <td class="paramname"><em>delim</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Advances the token in src to the next token between two delimiters provided by delim. </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramdir">[in]</td><td class="paramname">src</td><td>the source string view being reverse tokenized. </td></tr>
    <tr><td class="paramdir">[in]</td><td class="paramname">token</td><td>the current token obtained from tokenization. </td></tr>
    <tr><td class="paramdir">[in]</td><td class="paramname">delim</td><td>the delimiter that separates tokens. </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>the string view of the next available token. Repeating delimiters are skipped until the next token is found. If no further tokens can be found an empty <a class="el" href="structSV__Str__view.html" title="A read-only view of string data in C.">SV_Str_view</a> is returned with its pointer set to the start of the src string being iterated through. </dd></dl>
<dl class="section note"><dt>Note</dt><dd>A multi-character delimiter may yield different tokens in reverse than in the forward direction when partial matches occur and some portion of the delimiter is in a token. This is because the string is now being parsed from right to left. However, the token returned starts at the first character and is read from left to right between two delimiters as in the forward version. </dd></dl>

</div>
</div>
<a id="a6c9c796c96c8fd907aefee8e5a875c20" name="a6c9c796c96c8fd907aefee8e5a875c20"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a6c9c796c96c8fd907aefee8e5a875c20">&#9670;&#160;</a></span>SV_view_compare()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="str__view_8h.html#ab632a39b679bbed9a2f8a8cbb6c04807">SV_API</a> <a class="el" href="str__view_8h.html#a648d7dfc8555055b2e5b742d0aa6fdf7">SV_Order</a> SV_view_compare </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="structSV__Str__view.html">SV_Str_view</a>&#160;</td>
          <td class="paramname"><em>lhs</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">char const *&#160;</td>
          <td class="paramname"><em>rhs</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">size_t&#160;</td>
          <td class="paramname"><em>n</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Returns the standard C threeway comparison between cmp(lhs, rhs) between a <a class="el" href="structSV__Str__view.html" title="A read-only view of string data in C.">SV_Str_view</a> and a C string, bounded by n bytes of the right hand side. If <code>n</code> is shorter than the right hand side string the <code>n</code>th byte is compared. </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramdir">[in]</td><td class="paramname">lhs</td><td>the string view that serves as the left hand side of the order. </td></tr>
    <tr><td class="paramdir">[in]</td><td class="paramname">rhs</td><td>the null terminated string to compare against. </td></tr>
    <tr><td class="paramdir">[in]</td><td class="paramname">n</td><td>limit bytes of the comparison if less than right hand side length. </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>the order of the left hand side compared to the right hand side: <code>SV_ORDER_LESSER</code>, <code>SV_ORDER_EQUAL</code>, or <code>SV_ORDER_GREATER</code>.</dd></dl>
<p>Comparison is bounded by the shortest length between left hand side, right hand side string length, and the byte limit n. An error value is returned if bad input is provided such as a <a class="el" href="structSV__Str__view.html" title="A read-only view of string data in C.">SV_Str_view</a> with a NULL pointer field. </p>

</div>
</div>
</div><!-- contents -->
</div><!-- doc-content -->
<!-- start footer part -->
<div id="nav-path" class="navpath"><!-- id is needed for treeview function! -->
  <ul>
    <li class="navelem"><a class="el" href="dir_c0a9194a9d1810f5b7b1f18d57ea0ad0.html">str_view</a></li><li class="navelem"><a class="el" href="str__view_8h.html">str_view.h</a></li>
    <li class="footer">Generated by <a href="https://www.doxygen.org/index.html"><img class="footer" src="doxygen.svg" width="104" height="31" alt="doxygen"/></a> 1.9.6 </li>
  </ul>
</div>
</body>
</html>
